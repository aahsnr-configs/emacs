#+TITLE: Emacs Configuration
#+AUTHOR: Ahsanur Rahman
#+STARTUP: overview
#+PROPERTY: header-args:emacs-lisp :tangle ./init.el :mkdirp yes 

* Core Emacs Configuration
This section incorporates the sensible defaults and settings from the minimal-emacs.d project. This provides a robust and well-optimized foundation.
** Lexical Binding
#+begin_src emacs-lisp
;;; init.el --- DESCRIPTION -*- no-byte-compile: t; lexical-binding: t; -*-
#+end_src

** Package Management
#+begin_src emacs-lisp
(require 'package)

(setq package-archives '(("gnu" . "https://elpa.gnu.org/packages/")
                         ("nongnu" . "https://elpa.nongnu.org/nongnu/")
                         ("melpa" . "https://melpa.org/packages/")))
(package-initialize)
(unless package-archive-contents
  (package-refresh-contents))

(require 'use-package)
(setq use-package-always-ensure t
      use-package-expand-minimally t)
#+end_src

** General Behaviour
#+begin_src emacs-lisp
;; Allow for shorter "y" or "n" responses.
(defalias 'yes-or-no-p 'y-or-n-p)

;; Allow nested minibuffers.
(setq enable-recursive-minibuffers t)

;; Keep the cursor out of the read-only portions of the minibuffer.
(setq minibuffer-prompt-properties
      '(read-only t intangible t cursor-intangible t face minibuffer-prompt))
(add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

;; No beeping or blinking on errors.
(setq ring-bell-function 'ignore)
(setq visible-bell nil)

;; Disable the obsolete practice of end-of-line spacing from the typewriter era.
(setq sentence-end-double-space nil)

;; According to POSIX, a line should end with a newline.
(setq require-final-newline t)

;; Move point to top/bottom of buffer before signaling a scrolling error.
(setq scroll-error-top-bottom t)

;; If `scroll-conservatively' is set above 100, the window is never automatically recentered.
(setq scroll-conservatively 120)

;; Number of lines of margin at the top and bottom of a window.
(setq scroll-margin 0)

;; Prefer vertical splits over horizontal ones.
(setq split-width-threshold 170
      split-height-threshold nil)

;; Uniquify buffer names by adding a directory prefix.
(setq uniquify-buffer-name-style 'forward)

;; Delete files by moving them to the system trash.
(setq delete-by-moving-to-trash t)

;; Disable automatic backups and lockfiles.
(setq make-backup-files nil
      create-lockfiles nil)

;; Ask the user whether to terminate async compilations on exit.
(setq native-comp-async-query-on-exit t)

;; Skip confirmation prompts when creating a new file or buffer
(setq confirm-nonexistent-file-or-buffer nil)

;; Disable cursor blink for a more responsive feel and fewer redraws.
(blink-cursor-mode -1)
#+end_src

** Editing and Indentation
#+begin_src emacs-lisp
;; Set default indentation.
(setq-default indent-tabs-mode nil
              tab-width 2
              fill-column 80)

;; Enable multi-line commenting.
(setq comment-multi-line t)
(setq comment-empty-lines t)

;; Continue wrapped lines at whitespace.
(setq-default word-wrap t)
;; But truncate lines by default for performance. (visual-line-mode will override this)
(setq-default truncate-lines t)

(setq blink-matching-paren nil) ; Don't blink, it's distracting.
#+end_src

** Setup User
#+begin_src emacs-lisp
(setq user-full-name "Ahsanur Rahman"
      user-mail-address "ahsanur041@proton.me")
#+end_src

** Source Scripts
#+begin_src emacs-lisp
(require 'reload-config)
;;(require 'buffer-move)
;; (require 'garbage-collect)
;; (require 'update-packages)
#+end_src

** Frame Title Formatting
#+begin_src emacs-lisp
(setq-default
 frame-title-format
 '(:eval (format "[%%b%s] - %s"
           (if (buffer-modified-p)
                      " ‚Ä¢"
             "")
           system-name)))
#+end_src

** Session Management
#+begin_src emacs-lisp
;; Auto-revert in Emacs is a feature that automatically updates the
;; contents of a buffer to reflect changes made to the underlying file
;; on disk.
(use-package autorevert
  :ensure nil
  :commands (auto-revert-mode global-auto-revert-mode)
  :hook (after-init . global-auto-revert-mode)
  :custom
  (auto-revert-interval 3)
  (auto-revert-remote-files nil)
  (auto-revert-use-notify t)
  (auto-revert-avoid-polling nil)
  (auto-revert-verbose t))

;; Recentf is an Emacs package that maintains a list of recently
;; accessed files, making it easier to reopen files you have worked on
;; recently.
(use-package recentf
  :ensure nil
  :commands (recentf-mode recentf-cleanup)
  :hook (after-init . recentf-mode)
  :custom
  (recentf-auto-cleanup (if (daemonp) 300 'never))
  (recentf-exclude
   (list "^/\\(?:ssh\\|su\\|sudo\\)?:" ; From minimal-emacs.d
          "\\.?cache" ".cask" "url" "COMMIT_EDITMSG\\'" "bookmarks"
          "\\.\\(?:gz\\|gif\\|svg\\|png\\|jpe?g\\|bmp\\|xpm\\)$"
          "\\.?ido\\.last$" "\\.revive$" "/G?TAGS$" "/.elfeed/"
          "^/tmp/" "^/var/folders/.+$" "^/ssh:" "/persp-confs/"))

  :config
  ;; A cleanup depth of -90 ensures that `recentf-cleanup' runs before
  ;; `recentf-save-list', allowing stale entries to be removed before the list
  ;; is saved by `recentf-save-list', which is automatically added to
  ;; `kill-emacs-hook' by `recentf-mode'.
  (add-hook 'kill-emacs-hook #'recentf-cleanup -90))

;; savehist is an Emacs feature that preserves the minibuffer history between
;; sessions. It saves the history of inputs in the minibuffer, such as commands,
;; search strings, and other prompts, to a file. This allows users to retain
;; their minibuffer history across Emacs restarts.
(use-package savehist
  :ensure nil
  :commands (savehist-mode savehist-save)
  :hook (after-init . savehist-mode)
  :custom
  (savehist-autosave-interval 600)
  (savehist-additional-variables
   '(kill-ring                        ; clipboard
     register-alist                   ; macros
     mark-ring global-mark-ring       ; marks
     search-ring regexp-search-ring)))

;; save-place-mode enables Emacs to remember the last location within a file
;; upon reopening. This feature is particularly beneficial for resuming work at
;; the precise point where you previously left off.
(use-package saveplace
  :ensure nil
  :commands (save-place-mode save-place-local-mode)
  :hook (after-init . save-place-mode)
  :custom
  (save-place-limit 400))

;; Enable `auto-save-mode' to prevent data loss. Use `recover-file' or
;; `recover-session' to restore unsaved changes.
(setq auto-save-default t)

(setq auto-save-interval 300)
(setq auto-save-timeout 30)

;; When auto-save-visited-mode is enabled, Emacs will auto-save file-visiting
;; buffers after a certain amount of idle time if the user forgets to save it
;; with save-buffer or C-x s for example.
;;
;; This is different from auto-save-mode: auto-save-mode periodically saves
;; all modified buffers, creating backup files, including those not associated
;; with a file, while auto-save-visited-mode only saves file-visiting buffers
;; after a period of idle time, directly saving to the file itself without
;; creating backup files.
(setq auto-save-visited-interval 5)   ; Save after 5 seconds if inactivity
(auto-save-visited-mode 1)     
#+end_src

** Performance Tuning Packages
#+begin_src emacs-lisp
;;; Intelligent Garbage Collection
;; Run garbage collection only when Emacs is idle to prevent stuttering.
(use-package gcmh
  :config
  (gcmh-mode 1))

;;; Handling Large Files
;; Prevent slowdowns when opening very large files by disabling expensive modes.
(use-package so-long
  :hook (emacs-startup . so-long-mode))
#+end_src

** PGTK/Wayland Mitigations
This section contains settings specifically to mitigate performance and input
issues when running the Pure GTK (PGTK) build of Emacs on Wayland.

#+begin_src emacs-lisp
;; Mitigate Rendering Sluggishness:
;; The PGTK backend relies on CPU-intensive rendering. Disabling bidirectional
;; text reordering can improve responsiveness. This setting is safe to call
;; early as it does not depend on a graphical frame.
(setq-default bidi-display-reordering nil)

;; Mitigate Input Lag by disabling GTK input methods.
;; The function `pgtk-use-im-context` MUST be called after a frame is
;; created, otherwise it will error. We hook it into `after-make-frame-functions`
;; to ensure it runs at the correct time, both on startup and for new frames
;; created by emacsclient in daemon mode.
(when (fboundp 'pgtk-use-im-context)
  (add-hook 'after-make-frame-functions
            (lambda (frame)
              (with-selected-frame frame
                (pgtk-use-im-context nil)))))
#+end_src

** Auto-Tangle Files
Automatically tangle our Emacs.org config file when we save it.
#+begin_src emacs-lisp
(defun efs/org-babel-tangle-config ()
  (when (string-equal (buffer-file-name) (expand-file-name "vanilla-emacs.md" user-emacs-directory))
    ;; Dynamic scoping to the rescue
    (let ((org-confirm-babel-evaluate nil))
      (org-babel-tangle))))

(add-hook 'after-save-hook #'efs/org-babel-tangle-config)
#+end_src

** Automatic Package Updates
#+begin_src emacs-lisp
(use-package auto-package-update
  :custom
  (auto-package-update-interval 4)
  (auto-package-update-hide-results t)
  (auto-package-update-delete-old-versions t)
  :config
  ;; Run package updates automatically at startup, but only if the configured
  ;; interval has elapsed.
  (auto-package-update-maybe)
  (auto-package-update-at-time "10:00"))
#+end_src

* General Keybindings
#+begin_src emacs-lisp
(global-set-key (kbd "<escape>") 'keyboard-escape-quit)

(use-package general
  :after evil
  :config
  (general-create-definer ar/global-leader
    :keymaps '(normal insert visual emacs)
    :prefix "SPC"
    :global-prefix "C-SPC")
  
  (ar/global-leader
    ;; Core
    "SPC" '(execute-extended-command :wk "M-x")
    "q q" '(save-buffers-kill-terminal :wk "Quit Emacs")
    "q r" '(ar/reload-config :wk "Reload Config")))
#+end_src

* UI & Theming
** Fonts
This setup defines a robust function to find and set the best available font from a priority list. It prevents errors if a font is not installed and warns the user.
#+begin_src emacs-lisp
(defun ar/font-exists-p (font-name)
  "Check if a font with FONT-NAME exists on the system."
  (when (find-font (font-spec :name font-name))
    font-name))

(defun ar/set-fonts ()
  "Set fonts for the current frame, using the first available Nerd Font."
  (let* ((preferred-fonts '("JetBrainsMono Nerd Font"))
         (available-font (cl-find-if #'ar/font-exists-p preferred-fonts)))
    (if available-font
        (progn
          (set-face-attribute 'default nil :font available-font :height 140 :weight 'medium)
          (set-face-attribute 'fixed-pitch nil :font available-font :height 140 :weight 'medium)
          (set-face-attribute 'variable-pitch nil :font available-font :height 140 :weight 'medium)
          ;; Apply italic slant to comments and keywords for visual distinction
          (set-face-attribute 'font-lock-comment-face nil :slant 'italic)
          (set-face-attribute 'font-lock-keyword-face nil :slant 'italic))
      (warn "Nerd Fonts not found. Please install JetBrainsMono, FiraCode, or Hack Nerd Font."))))

;; Set fonts on startup and for new frames in daemon mode.
(if (daemonp)
    (add-hook 'after-make-frame-functions (lambda (frame) (with-selected-frame frame (ar/set-fonts))))
  (ar/set-fonts))
;; Uncomment the following line if line spacing needs adjusting.
(setq-default line-spacing 0.01)
(setq font-lock-maximum-decoration t)
(setq inhibit-compacting-font-caches t)
#+end_src

** Line Numbers
Enable line numbers for some modes
#+begin_src emacs-lisp
(dolist (mode '(prog-mode-hook
                conf-mode-hook))
  (add-hook mode (lambda () (display-line-numbers-mode t))))
#+end_src

** Theming
#+begin_src emacs-lisp
(use-package doom-themes
  :custom
  (doom-themes-enable-bold t)
  (doom-themes-enable-italic t)
  :config
  (load-theme 'doom-tokyo-night t)
  (doom-themes-neotree-config)
  (doom-themes-visual-bell-config)
  (doom-themes-org-config)
  
  ;; Set distinct colors for bold and italic
  (custom-set-faces
   '(bold ((t (:foreground "#7aa2f7" :weight bold))))
   '(italic ((t (:foreground "#bb9af7" :slant italic))))))
#+end_src

** Solaire Mode
#+begin_src emacs-lisp
(use-package solaire-mode
  ;;:defer t
  :hook (after-init . solaire-global-mode))
#+end_src

** Nerd Icons
#+begin_src emacs-lisp
(use-package nerd-icons
  :defer t
  :custom
  (nerd-icons-font-family "JetBrainsMono Nerd Font")
  (nerd-icons-color-icons t))
#+end_src

** Modeline
#+begin_src emacs-lisp
(use-package doom-modeline
  :hook (after-init . doom-modeline-mode)
  :config
  (setq doom-modeline-height 28)
  (setq doom-modeline-bar-width 3)
  (setq doom-modeline-icon t)
  (setq doom-modeline-major-mode-icon t)
  (setq doom-modeline-major-mode-color-icon t)
  (setq doom-modeline-buffer-file-name-style 'relative)
  (setq doom-modeline-buffer-state-icon t)
  (setq doom-modeline-buffer-modification-icon t)
  (setq doom-modeline-minor-modes nil)
  (setq doom-modeline-enable-word-count nil)
  (setq doom-modeline-buffer-encoding t)
  (setq doom-modeline-indent-info nil)
  (setq doom-modeline-checker-simple-format t)
  (setq doom-modeline-vcs-max-length 12)
  (setq doom-modeline-env-version t)
  (setq doom-modeline-irc-stylize 'identity)
  (setq doom-modeline-github-timer nil)
  (setq doom-modeline-gnus-timer nil)
    (custom-set-faces
   '(mode-line ((t (:family "JetBrainsMono Nerd Font" :height 1.0))))
   '(mode-line-active ((t (:family "JetBrainsMono Nerd Font" :height 1.0)))) ; For 29+
   '(mode-line-inactive ((t (:family "JetBrainsMono Nerd Font" :height 1.0)))))
)
#+end_src

** Dashboard
#+begin_src emacs-lisp
(use-package dashboard
  :after nerd-icons
  :init (dashboard-setup-startup-hook)
  :custom
  (initial-buffer-choice (lambda () (get-buffer-create dashboard-buffer-name)))
  (dashboard-center-content t)
  (dashboard-items '((recents . 5) (projects . 5) (agenda . 5)))
  (dashboard-startup-banner 'logo)
  (dashboard-display-icons-p t)
  (dashboard-icon-type 'nerd-icons))
#+end_src

** Which Key
#+begin_src emacs-lisp
(use-package which-key
  :defer t
  :hook (after-init . which-key-mode)
  :custom
  (which-key-idle-delay 0.1)
  (which-key-separator " ‚Üí ")
  (which-key-popup-type 'minibuffer))
#+end_src

** Hide Modeline
#+begin_src emacs-lisp
;; <
(defun ar/hide-modeline-for-special-buffers ()
  "Hide the modeline in special buffers starting and ending with '*'.
An exclusion list prevents this for essential buffers like *scratch*
or compilation buffers where the modeline provides useful info."
  (let ((buf-name (buffer-name))
        ;; Add buffer names here to prevent their modelines from being hidden.
        (exclude-list '("*scratch*"
                         "*Messages*"
                         "*compilation*"
                         "*Agenda Commands*"
                         "*grep*"
                         "*vterm*")))
    (when (and buf-name
               (> (length buf-name) 2) ; Ensure buffer name is not just "**"
               (string-prefix-p "*" buf-name)
               (string-suffix-p "*" buf-name)
               (not (member buf-name exclude-list)))
      (setq-local mode-line-format nil))))

;; This hook runs whenever a buffer's major mode is initialized,
;; applying the rule to all new and existing special buffers.
(add-hook 'after-change-major-mode-hook #'ar/hide-modeline-for-special-buffers)
#+end_src

* Evil
** Anzu
*Show number of matches in mode-line while searching*
#+begin_src emacs-lisp
(use-package anzu
  :defer t
  :bind (([remap query-replace] . anzu-query-replace)
         ([remap query-replace-regexp] . anzu-query-replace-regexp)
         :map isearch-mode-map
         ([remap isearch-query-replace] . anzu-isearch-query-replace)
         ([remap isearch-query-replace-regexp] . anzu-isearch-query-replace-regexp))
  :hook (after-init . global-anzu-mode))
#+end_src

** Undo System
#+begin_src emacs-lisp
;; The undo-fu package is a lightweight wrapper around Emacs' built-in undo
;; system, providing more convenient undo/redo functionality.
(use-package undo-fu
  :defer t
  :commands (undo-fu-only-undo
             undo-fu-only-redo
             undo-fu-only-redo-all
             undo-fu-disable-checkpoint)
  :config
  (global-unset-key (kbd "C-z"))
  (global-set-key (kbd "C-z") 'undo-fu-only-undo)
  (global-set-key (kbd "C-S-z") 'undo-fu-only-redo))

;; The undo-fu-session package complements undo-fu by enabling the saving
;; and restoration of undo history across Emacs sessions, even after restarting.
(use-package undo-fu-session
  :defer t
  :commands undo-fu-session-global-mode
  :hook (after-init . undo-fu-session-global-mode))
#+end_src

** Core Evil
#+begin_src emacs-lisp
;; Uncomment the following if you are using undo-fu
(setq evil-undo-system 'undo-fu)

;; Vim emulation
(use-package evil
  :init
  (setq evil-want-integration t)
  (setq evil-want-keybinding nil)

  :config
  (evil-mode 1)

  :custom
  (evil-ex-visual-char-range t)
  (evil-ex-search-vim-style-regexp t)
  (evil-split-window-below t)
  (evil-vsplit-window-right t)
  (evil-echo-state nil)
  (evil-move-cursor-back nil)
  (evil-v$-excludes-newline t)
  (evil-want-C-h-delete t)
  (evil-want-C-u-delete t)
  (evil-want-fine-undo t)
  (evil-move-beyond-eol t)
  (evil-search-wrap nil)
  (evil-want-Y-yank-to-eol t))
#+end_src

** Evil Collection
#+begin_src emacs-lisp
(use-package evil-collection
  :after evil
  :init
  ;; It has to be defined before evil-colllection
  (setq evil-collection-setup-minibuffer t)
  :config
  (evil-collection-init))
#+end_src

** Evil Extensions
#+begin_src emacs-lisp
(use-package evil-surround :hook (evil-mode . global-evil-surround-mode))
(use-package evil-nerd-commenter :after evil)

(use-package evil-numbers :after evil)
(use-package evil-args :after evil)
(use-package evil-anzu :after evil)
(use-package evil-exchange :after evil :config (evil-exchange-install))
(use-package evil-indent-plus :after evil :config (evil-indent-plus-default-bindings))
(use-package evil-visualstar :hook (evil-mode . global-evil-visualstar-mode))
(use-package evil-matchit :hook (evil-mode . global-evil-matchit-mode))
(use-package evil-snipe :after evil :config (evil-snipe-mode 1) (evil-snipe-override-mode 1))

(use-package evil-lion
  :after evil
  :hook (prog-mode . evil-lion-mode))

(use-package evil-multiedit :after evil :config (evil-multiedit-default-keybinds))
(use-package evil-goggles :hook (evil-mode . evil-goggles-mode) :custom (evil-goggles-duration 0.1))

(use-package evil-escape
  :hook (evil-mode . evil-escape-mode)
  :custom
  (evil-escape-key-sequence "jk")
  (evil-escape-delay 0.2)
  (evil-escape-excluded-modes '(dired-mode)))

(use-package goggles
  :defer t
  :hook ((prog-mode text-mode org-mode) . goggles-mode)
  :config
  (setq-default goggles-pulse t)) ;; set to nil to disable pulsing
#+end_src

** Keybindings
#+begin_src emacs-lisp
(with-eval-after-load 'evil-maps
  (evil-define-key '(normal visual) 'global "gc" 'evilnc-comment-or-uncomment-lines))
#+end_src

* Editor Behaviour
** Lines Behaviour
#+begin_src emacs-lisp
;; Highlight the current line
(add-hook 'after-init-hook #'global-hl-line-mode)
;; Use visual line mode for soft wrapping instead of truncating lines
(add-hook 'after-init-hook #'global-visual-line-mode)
#+end_src

** Smartparens
#+begin_src emacs-lisp
(use-package smartparens
  :after evil
  :hook ((prog-mode . smartparens-mode)
         (text-mode . smartparens-mode)
         (markdown-mode . smartparens-mode)
         (org-mode . smartparens-mode))
  :config
  ;; --- UI and Behavior Customizations ---
  (setq sp-show-pair-delay 0.1
        sp-show-pair-from-inside t))
#+end_src

** Hydra for Key Chord Menus
This section explicitly sets up `hydra` and `pretty-hydra`, which are used to
create dispatch menus like the one for `hideshow`.
#+begin_src emacs-lisp
(use-package hydra :defer t)

(use-package pretty-hydra
  :defer t
  :after hydra)
#+end_src
** Automatic parenthesis pairing
#+begin_src emacs-lisp
(use-package elec-pair
  :ensure nil
  :hook (after-init . electric-pair-mode)
  :init (setq electric-pair-inhibit-predicate 'electric-pair-conservative-inhibit))

(add-hook 'org-mode-hook (lambda ()
           (setq-local electric-pair-inhibit-predicate
                   `(lambda (c)
                  (if (char-equal c ?<) t (,electric-pair-inhibit-predicate c))))))
#+end_src

** Rainbow Delimiters
#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :defer t
  :hook ((text-mode . rainbow-delimiters-mode)
         (prog-mode . rainbow-delimiters-mode)
         (org-src-mode-hook . rainbow-delimiters-mode))

  ;; Custom faces updated for the Tokyonight color palette.
  :custom-face
  (rainbow-delimiters-depth-1-face ((t (:foreground "#7aa2f7"))))  ; Blue
  (rainbow-delimiters-depth-2-face ((t (:foreground "#bb9af7"))))  ; Magenta
  (rainbow-delimiters-depth-3-face ((t (:foreground "#e0af68"))))  ; Yellow
  (rainbow-delimiters-depth-4-face ((t (:foreground "#73daca"))))  ; Cyan
  (rainbow-delimiters-depth-5-face ((t (:foreground "#f7768e"))))  ; Red
  (rainbow-delimiters-depth-6-face ((t (:foreground "#9ece6a"))))  ; Green
  (rainbow-delimiters-depth-7-face ((t (:foreground "#ff9e64"))))  ; Orange
  (rainbow-delimiters-depth-8-face ((t (:foreground "#c0caf5"))))  ; Foreground
  (rainbow-delimiters-depth-9-face ((t (:foreground "#a9b1d6"))))) ; Sub-Foreground
#+end_src

** Rainbow Mode
#+begin_src emacs-lisp
(use-package rainbow-mode
  :defer t
  :hook ((prog-mode . rainbow-mode)
         (org-mode . rainbow-mode)))
#+end_src

** Buffer Terminator
#+begin_src emacs-lisp
(use-package buffer-terminator
  :defer t
  :custom
  ;; Enable/Disable verbose mode to log buffer cleanup events
  (buffer-terminator-verbose nil)

  ;; Set the inactivity timeout (in seconds) after which buffers are considered
  ;; inactive (default is 30 minutes):
  (buffer-terminator-inactivity-timeout (* 30 60)) ; 30 minutes

  ;; Define how frequently the cleanup process should run (default is every 10
  ;; minutes):
  (buffer-terminator-interval (* 10 60)) ; 10 minutes

  :config
  (buffer-terminator-mode 1))
#+end_src

** Inhibit Mouse
#+begin_src emacs-lisp
(use-package inhibit-mouse
  :config
  (if (daemonp)
      (add-hook 'server-after-make-frame-hook #'inhibit-mouse-mode)
    (inhibit-mouse-mode 1)))
#+end_src

** Shackle for Popup Window Management
This provides a declarative way to control where and how special-purpose buffers
appear, ensuring a consistent and predictable windowing layout.
#+begin_src emacs-lisp
(use-package shackle
  :defer t
  :hook (after-init . shackle-mode)
  :config
  (setq shackle-rules
   '(;; --- DAP Mode Debugger UI Rules ---
     ("\\`\\*dap-repl\\*" :align 'bottom :size 0.25)
     ("\\`\\*dap-ui-.+\\*" :align 'right :size 0.33)
     ("\\`\\*Help" :align bottom :size 0.3)
     ("^\\*.*compilation.*\\*$" :align bottom :size 0.3)
     ("^\\*grep.*\\*$" :align bottom :size 0.3)
     ("\\`\\*Embark Collect" :align bottom :size 0.25))
   shackle-inhibit-window-quit-on-same-buffer t))
#+end_src

** Combobulate
#+begin_src emacs-lisp
(use-package combobulate
  :defer t
  :custom
  ;; You can customize Combobulate's key prefix here.
  ;; Note that you may have to restart Emacs for this to take effect!
  (combobulate-key-prefix "C-c o")
  :hook ((prog-mode . combobulate-mode))
  ;; Amend this to the directory where you keep Combobulate's source
  ;; code.
  :load-path ("~/.config/emacs/lisp/combobulate"))
#+end_src
** Helpful
*helpful* is an alternative to the built-in Emacs help that provides much more contextual information.
#+begin_src emacs-lisp
(use-package helpful
  :commands (helpful-callable
             helpful-variable
             helpful-key
             helpful-command
             helpful-at-point
             helpful-function)
  :bind
  ([remap describe-command] . helpful-command)
  ([remap describe-function] . helpful-callable)
  ([remap describe-key] . helpful-key)
  ([remap describe-symbol] . helpful-symbol)
  ([remap describe-variable] . helpful-variable)
  :custom
  (helpful-max-buffers 7))
#+end_src

** Wgrep: Writable Grep
#+begin_src emacs-lisp
(use-package wgrep
  :commands (wgrep-change-to-wgrep-mode)
  :config
  ;; evil-collection provides bindings like :wq to save and :q! to abort.
  (setq wgrep-auto-save-buffer t))
#+end_src

** Indent Bars
#+begin_src emacs-lisp
(use-package indent-bars
  :hook ((prog-mode . indent-bars-mode)
         (atex-mode . indent-bars-mode))
  :config
  (require 'indent-bars-ts)
  (setopt indent-bars-no-descend-lists t
          indent-bars-treesit-support t
          indent-bars-width-frac 0.3))
#+end_src

** Jinx
#+begin_src emacs-lisp
(use-package jinx
  :hook (after-init . jinx-mode)
  :custom
  ;; Sensibly disable Jinx in modes where spell-checking is not desired.
  ;; This includes programming modes, UI-centric modes, and special buffers.
  (jinx-disabled-modes
   '(prog-mode           ; All programming modes
     conf-mode           ; All configuration file modes
     emacs-lisp-mode     ; Specifically for elisp
     dired-mode          ; File manager
     ibuffer-mode        ; Buffer list
     neotree-mode        ; File tree
     magit-status-mode   ; Magit UI
     magit-log-mode
     magit-diff-mode
     magit-branch-mode
     org-agenda-mode     ; Agenda view is not for writing
     org-src-mode        ; Don't check inside code blocks
     dashboard-mode      ; Startup dashboard
     which-key-mode      ; Keybinding helper
     help-mode           ; Help buffers
     Info-mode           ; Info documentation
     embark-collect-mode ; Embark's special buffer
     vterm-mode          ; Terminal emulator
     pdf-view-mode))     ; PDF viewer

    ;; Ensure the personal dictionary file exists, creating it if necessary.
  (let ((dict-file (expand-file-name "dict.txt" user-emacs-directory)))
    (unless (file-exists-p dict-file)
      (write-region "" nil dict-file)))

  (ar/global-leader
    "j" '(:ignore t :wk "jinx (spellcheck)")
    "j c" '(jinx-correct :wk "Correct word at point")
    "j n" '(jinx-next-error :wk "Go to next error")
    "j p" '(jinx-previous-error :wk "Go to previous error")
    "j s" '(jinx-suggest :wk "Show suggestions")
    "j a" '(jinx-add-word-to-personal-dictionary :wk "Add to dictionary")
    "j l" '(jinx-languages :wk "Select language")
    "j t" '(jinx-toggle-checking :wk "Toggle checking in buffer")))


#+end_src

** Aggressive Indent

#+begin_src emacs-lisp
(use-package aggressive-indent
  :defer t
  :hook (after-init . global-aggressive-indent-mode)
  :config
  ;; Disable in some modes
  (dolist (mode '(gitconfig-mode
                  asm-mode web-mode html-mode
                  css-mode css-ts-mode
                  go-mode go-ts-mode
                  python-ts-mode yaml-ts-mode
                  scala-mode
                  shell-mode term-mode vterm-mode
                  prolog-inferior-mode))
    (add-to-list 'aggressive-indent-excluded-modes mode))

  ;; Disable in some commands
  (add-to-list 'aggressive-indent-protected-commands #'delete-trailing-whitespace t)

  ;; Be slightly less aggressive in C/C++/C#/Java/Go/Swift
  (add-to-list 'aggressive-indent-dont-indent-if
               '(and (derived-mode-p 'c-mode 'c++-mode 'csharp-mode
                                     'java-mode 'go-mode 'swift-mode)
                     (null (string-match "\\([;{}]\\|\\b\\(if\\|for\\|while\\)\\b\\)"
                                         (thing-at-point 'line))))))
#+end_src

** Symbol Highlighting
#+begin_src emacs-lisp
(use-package symbol-overlay
  :defer t
  :hook (prog-mode . symbol-overlay-mode)
  :bind (("M-i" . symbol-overlay-put)
         ("M-n" . symbol-overlay-jump-next)
         ("M-p" . symbol-overlay-jump-prev)))
#+end_src

** TODO Keyword Highlighting
*Use tokyonight theme colors*
#+begin_src emacs-lisp
(use-package hl-todo
  :defer t
  :hook (after-init . global-hl-todo-mode)
  :config
  (setq hl-todo-highlight-punctuation ":"
        hl-todo-keyword-faces
        `(("TODO"       . ,(face-foreground 'error))
          ("FIXME"      . ,(face-foreground 'error))
          ("NOTE"       . ,(face-foreground 'success))
          ("HACK"       . ,(face-foreground 'warning))
          ("REVIEW"     . ,(face-foreground 'warning))
          ("PERF"       . ,(face-foreground 'warning)))))
#+end_src

** Avy: Jump to things in Emacs tree-style
#+begin_src emacs-lisp
(use-package avy
  :defer t
  :bind (("C-:"   . avy-goto-char)
         ("C-'"   . avy-goto-char-2)
         ("M-g l" . avy-goto-line)
         ("M-g w" . avy-goto-word-1)
         ("M-g e" . avy-goto-word-0))
  :hook (after-init . avy-setup-default)
  :config (setq avy-all-windows nil
                avy-all-windows-alt t
                avy-background t
                avy-style 'pre))

;; Kill text between the point and the character CHAR
(use-package avy-zap
  :defer t
  :bind (("M-z" . avy-zap-to-char-dwim)
         ("M-Z" . avy-zap-up-to-char-dwim)))

#+end_src

** Expand Region
#+begin_src emacs-lisp
(use-package expand-region
  :defer t
  :bind ("C-=" . er/expand-region)
  :config
  ;; Add tree-sitter integration for semantic expansion
  (defun treesit-mark-bigger-node ()
    "Use tree-sitter to mark regions."
    (let* ((root (treesit-buffer-root-node))
           (node (treesit-node-descendant-for-range root (region-beginning) (region-end)))
           (node-start (treesit-node-start node))
           (node-end (treesit-node-end node)))
      (when (and (= (region-beginning) node-start) (= (region-end) node-end))
        (when-let* ((node (treesit-node-parent node)))
          (setq node-start (treesit-node-start node)
                node-end (treesit-node-end node))))
      (set-mark node-end)
      (goto-char node-start)))
  (add-to-list 'er/try-expand-list 'treesit-mark-bigger-node))
#+end_src

** Visual Feedback on Jump
#+begin_src emacs-lisp
(use-package pulse
  :defer t
  :ensure nil
  :hook ((dumb-jump-after-jump imenu-after-jump bookmark-after-jump next-error) . pulse-momentary-highlight-one-line))
#+end_src

** Delete Selection if you insert
#+begin_src emacs-lisp
(use-package delsel
  :ensure nil
  :hook (after-init . delete-selection-mode))
#+end_src

** Redefine M-< and M-> for some modes
#+begin_src emacs-lisp
(use-package beginend
  :defer t
  :hook (after-init . beginend-global-mode))
#+end_src

** Handling capitalized subwords in a nomenclature
#+begin_src emacs-lisp
(use-package subword
  :defer t
  :ensure nil
  :hook ((prog-mode . subword-mode)
         (minibuffer-setup . subword-mode)))
#+end_src

** Edit multiple regions in the same way simultaneously
#+begin_src emacs-lisp
(use-package iedit
  :defer t
  :defines desktop-minor-mode-table
  :bind (("C-;" . iedit-mode)
         ("C-x r RET" . iedit-rectangle-mode)
         :map isearch-mode-map ("C-;" . iedit-mode-from-isearch)
         :map esc-map ("C-;" . iedit-execute-last-modification)
         :map help-map ("C-;" . iedit-mode-toggle-on-function))
  :config
  ;; Avoid restoring `iedit-mode'
  (with-eval-after-load 'desktop
    (add-to-list 'desktop-minor-mode-table
                 '(iedit-mode nil))))
#+end_src

** Smartly select region, rectangle, multi cursors
#+begin_src emacs-lisp
(use-package smart-region
  :defer t
  :hook (after-init . smart-region-on))
#+end_src

** Flexible Text Folding
#+begin_src emacs-lisp
(use-package hideshow
  :ensure nil
  :after (hydra pretty-hydra) ;; This ensures hydra macros are available first
  :hook (prog-mode . hs-minor-mode)
  :bind (:map hs-minor-mode-map
         ("C-~" . hideshow-hydra/body)
         ("C-S-<escape>" . hideshow-hydra/body))
  :config
  ;; Define the pretty hydra menu for hideshow commands
  (pretty-hydra-define hideshow-hydra (:title (pretty-hydra-title "HideShow" 'octicon "nf-oct-fold")
                                       :color amaranth :quit-key ("q" "C-g"))
    ("Fold"
     (("t" hs-toggle-all "toggle all")
      ("a" hs-show-all "show all")
      ("i" hs-hide-all "hide all")
      ("g" hs-toggle-hiding "toggle hiding")
      ("c" hs-cycle "cycle block")
      ("s" hs-show-block "show block")
      ("h" hs-hide-block "hide block")
      ("l" hs-hide-level "hide level"))
     "Move"
     (("C-a" mwim-beginning-of-code-or-line "‚≠∞")
      ("C-e" mwim-end-of-code-or-line "‚≠≤")
      ("C-b" backward-char "‚Üê")
      ("C-n" next-line "‚Üì")
      ("C-p" previous-line "‚Üë")
      ("C-f" forward-char "‚Üí")
      ("C-v" pager-page-down "‚Üò")
      ("M-v" pager-page-up "‚Üñ")
      ("M-<" beginning-of-buffer "‚≠∂")
      ("M->" end-of-buffer "‚≠∏"))))

  ;; Your existing custom functions remain here
  (defun hs-cycle (&optional level)
    (interactive "p")
    (let (message-log-max
          (inhibit-message t))
      (if (= level 1)
          (pcase last-command
            ('hs-cycle
             (hs-hide-level 1)
             (setq this-command 'hs-cycle-children))
            ('hs-cycle-children
             (save-excursion (hs-show-block))
             (setq this-command 'hs-cycle-subtree))
            ('hs-cycle-subtree
             (hs-hide-block))
            (_
             (if (not (hs-already-hidden-p))
                 (hs-hide-block)
               (hs-hide-level 1)
               (setq this-command 'hs-cycle-children))))
        (hs-hide-level level)
        (setq this-command 'hs-hide-level))))

  (defun hs-toggle-all ()
    "Toggle hide/show all."
    (interactive)
    (pcase last-command
      ('hs-toggle-all
       (save-excursion (hs-show-all))
       (setq this-command 'hs-global-show))
      (_ (hs-hide-all))))

  (defun hs-display-code-line-counts (ov)
    "Display line counts when hiding codes."
    (when (eq 'code (overlay-get ov 'hs))
      (overlay-put ov 'display
                   (concat
                    " "
                    (propertize
                     (if (char-displayable-p ?‚è∑) "‚è∑" "...")
                     'face 'shadow)
                    (propertize
                     (format " (%d lines)"
                             (count-lines (overlay-start ov)
                                          (overlay-end ov)))
                     'face '(:inherit shadow :height 0.8))
                    " "))))
  (setq hs-set-up-overlay #'hs-display-code-line-counts))
#+end_src

** Move to the beginning/end of line or code
#+begin_src emacs-lisp
(use-package mwim
  :defer t
  :bind (([remap move-beginning-of-line] . mwim-beginning)
         ([remap move-end-of-line] . mwim-end)))
#+end_src

** Goto last change
#+begin_src emacs-lisp
(use-package goto-chg
  :defer t
  :bind ("C-," . goto-last-change))
#+end_src

** Handling capitalized subwords in a nomenclature
#+begin_src emacs-lisp
(use-package subword
  :defer t
  :ensure nil
  :hook ((prog-mode . subword-mode)
         (minibuffer-setup . subword-mode)))
#+end_src

* Completion Framework
** Base Completion
#+begin_src emacs-lisp
(use-package emacs
  :ensure nil
  :custom
  (tab-always-indent 'complete)
  (text-mode-ispell-word-completion nil)
  (read-extended-command-predicate #'command-completion-default-include-p))
#+end_src

** Orderless for Advanced Filtering
#+begin_src emacs-lisp
(use-package orderless
  :custom
  ;; Use orderless as the primary completion style.
  (completion-styles '(orderless basic))
  (completion-category-defaults nil)
  ;; Use standard completion for file paths for a more predictable experience.
  (orderless-component-separator #'orderless-escapable-split-on-space)
  (completion-category-overrides '((file (styles basic partial-completion))))
  ;; Add dispatchers for more precise filtering (e.g., =literal, %regexp)
  (orderless-dispatchers
   '(orderless-consult-dispatch orderless-affix-dispatch)))
#+end_src

** Vertico: The Vertical Completion UI
#+begin_src emacs-lisp
(use-package vertico
  :hook (after-init . vertico-mode)
  :custom
  (vertico-resize nil)
  (vertico-cycle t)
  (vertico-count 10))
#+end_src

** Marginalia
#+begin_src emacs-lisp
(use-package marginalia
  :hook (after-init . marginalia-mode))
#+end_src

** Nerd Icons Completion
#+begin_src emacs-lisp
(use-package nerd-icons-completion
  :config
  (add-hook 'marginalia-mode-hook #'nerd-icons-completion-marginalia-setup)
  (nerd-icons-completion-mode))
#+end_src

** Consult
#+begin_src emacs-lisp
(use-package consult
  :hook (completion-list-mode . consult-preview-at-point-mode)
  :init
  (setq register-preview-delay 0.3)
  (setq consult-prompt-margin 0)
  (setq consult-preview-key 'any)

  :custom
  (consult-narrow-key "<")
  (consult-find-args "fd --hidden --strip-cwd --type f --color=never --follow --exclude .git")
  (consult-ripgrep-args "rg --null --line-buffered --color=never --smart-case --no-heading --line-number --hidden --glob '!.git/'")
  ;; Augment the default consult-buffer sources to include recent files and
  ;; project-specific recent files for a more powerful buffer switcher.
  (consult-buffer-sources
   '(;;consult--source-buffer
     consult--source-recent-file
     consult--source-project-recent-file
     consult--source-bookmark))

  :config
  ;; Configure preview keys for various commands.
  ;; A delayed preview is used to avoid performance issues.
  (consult-customize
   consult-theme :preview-key '(:debounce 0.05 any)
   consult-ripgrep consult-git-grep consult-grep
   consult-bookmark consult-recent-file consult-xref
   consult--source-bookmark consult--source-file-register
   consult--source-recent-file consult--source-project-recent-file
   :preview-key '(:debounce 0.1 any)))
#+end_src

** Embark
#+begin_src emacs-lisp
(use-package embark
  :bind
  (("C-." . embark-act)         ;; pick some comfortable binding
   ("C-;" . embark-dwim)        ;; good alternative: M-.
   ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'

  :init
  (setq prefix-help-command #'embark-prefix-help-command)
  :config
  (define-key embark-collect-mode-map (kbd "e") #'embark-export)
  ;; Hide the mode line of the Embark live/completions buffers
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none)))))
#+end_src

** Embark Consult
#+begin_src emacs-lisp
(use-package embark-consult
  :after (embark consult)
  :hook
  (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

** Corfu: The Core UI
#+begin_src emacs-lisp
(use-package corfu
  :hook (after-init . global-corfu-mode)
  :config
  (corfu-history-mode)
  (corfu-popupinfo-mode) ; don't set delay or 
  :bind
  (:map corfu-map
        ("TAB" . corfu-next)
        ([tab] . corfu-next)
        ("S-TAB" . corfu-previous)
        ([backtab] . corfu-previous)
        ("C-c h" . corfu-info-documentation))
  :custom
  (corfu-cycle t)
  (corfu-auto t)
  (corfu-auto-resize nil)
  (corfu-auto-delay 0.13)
  (corfu-preselect 'prompt)
  (corfu-quit-at-boundary 'separator) ; hecks if the current completion boundary has been left
  (corfu-quit-no-match 'separator) ; corfu completion will quit eagerly
  (corfu-on-exact-match nil))

(orderless-define-completion-style orderless-literal-only
  (orderless-style-dispatchers nil)
  (orderless-matching-styles '(orderless-literal)))

(add-hook 'corfu-mode-hook
          (lambda ()
            (setq-local completion-styles '(orderless-literal-only basic)
                        completion-category-overrides nil
                        completion-category-defaults nil)))
#+end_src

** Nerd Icons for Corfu
#+begin_src emacs-lisp
(use-package nerd-icons-corfu
  :after (corfu nerd-icons)
  :config (add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter))
#+end_src

** Cape: Completion Backends
#+begin_src emacs-lisp
(use-package cape
  :commands (cape-file cape-elisp-block cape-keyword)
  :autoload (cape-wrap-noninterruptible cape-wrap-nonexclusive cape-wrap-buster)
  :autoload (cape-wrap-silent cape-wrap-purify)
  :init
  ;; (add-to-list 'completion-at-point-functions #'cape-dabbrev)
  (add-to-list 'completion-at-point-functions #'cape-file)
  (add-to-list 'completion-at-point-functions #'cape-elisp-block)
  (add-to-list 'completion-at-point-functions #'cape-keyword)
  ;; (add-to-list 'completion-at-point-functions #'cape-abbrev)

  ;; Make these capfs composable.
  (advice-add 'lsp-completion-at-point :around #'cape-wrap-noninterruptible)
  (advice-add 'lsp-completion-at-point :around #'cape-wrap-nonexclusive)
  (advice-add 'comint-completion-at-point :around #'cape-wrap-nonexclusive)
  (advice-add 'eglot-completion-at-point :around #'cape-wrap-buster)
  (advice-add 'eglot-completion-at-point :around #'cape-wrap-nonexclusive)
  (advice-add 'pcomplete-completions-at-point :around #'cape-wrap-nonexclusive))
#+end_src

** Dabbrev
#+begin_src emacs-lisp
(use-package dabbrev
  :ensure nil
  ;; Swap M-/ and C-M-/
  :bind (("M-/" . dabbrev-completion)
         ("C-M-/" . dabbrev-expand))
  :config
  (add-to-list 'dabbrev-ignored-buffer-regexps "\\` ")
  ;; Available since Emacs 29 (Use `dabbrev-ignored-buffer-regexps' on older Emacs)
  (add-to-list 'dabbrev-ignored-buffer-modes 'doc-view-mode)
  (add-to-list 'dabbrev-ignored-buffer-modes 'pdf-view-mode)
  (add-to-list 'dabbrev-ignored-buffer-modes 'tags-table-mode))
#+end_src

* Org Mode
** Directory Structure
#+begin_src emacs-lisp
(defvar my/org-directory "~/org/"
  "Base directory for all org files.")

(defvar my/org-roam-directory (expand-file-name "roam/" my/org-directory)
  "Directory for org-roam files.")

(defvar my/org-downloads-directory (expand-file-name "downloads/" my/org-directory)
  "Directory for org-download files.")

(defvar my/org-noter-directory (expand-file-name "noter/" my/org-directory)
  "Directory for org-noter files.")

(defvar my/org-archive-directory (expand-file-name "archive/" my/org-directory)
  "Directory for archived org files.")

;; Create necessary directories, including subdirectories for Org Roam templates
(dolist (dir (list my/org-directory
                   my/org-roam-directory
                   my/org-downloads-directory
                   my/org-noter-directory
                   my/org-archive-directory
                   (expand-file-name "projects/" my/org-roam-directory)
                   (expand-file-name "literature/" my/org-roam-directory)
                   (expand-file-name "ideas/" my/org-roam-directory)
                   (expand-file-name "zettel/" my/org-roam-directory)
                   (expand-file-name "attachments/" my/org-directory)
                   (expand-file-name "reviews/" my/org-directory)
                   (expand-file-name "backups/" my/org-directory)))
  (unless (file-directory-p dir)
    (make-directory dir t)))

;; This function now uses `consult--grep-builder` to rapidly
;; find project files using ripgrep, avoiding a major performance bottleneck.
(defun ar/find-org-projects ()
  "Return a list of all Org files with a \"project\" tag for capture."
  (let* ((builder (consult--grep-builder
                   (list consult-ripgrep-args
                         "--files-with-matches"
                         "--glob=*.org"
                         "^#\\+filetags:.*:project:.*"
                         (expand-file-name my/org-directory)))))
    (mapcar (lambda (file)
              (list (file-name-nondirectory file) file))
            (consult--grep-sync builder))))
#+end_src

** Better Font Faces
#+begin_src emacs-lisp
(defun ar/org-font-setup ()
  ;; Replace list hyphen with dot
  (font-lock-add-keywords 'org-mode
                          '(("^ *\\([-]\\) "
                             (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "‚Ä¢"))))))

  ;; Set faces for heading levels
  (dolist (face '((org-level-1 . 1.2)
                  (org-level-2 . 1.13)
                  (org-level-3 . 1.10)
                  (org-level-4 . 1.07)
                  (org-level-5 . 1.05)
                  (org-level-6 . 1.03)
                  (org-level-7 . 1.02)
                  (org-level-8 . 1)))
    (set-face-attribute (car face) nil :font "JetBrainsMono Nerd Font" :weight 'bold :height (cdr face))))
#+end_src

** Core Configuration
#+begin_src emacs-lisp
(use-package org
  :ensure nil
  :mode ("\\.org\\'" . org-mode)
  :hook
  ;; Hooks for org-mode itself.
  ((org-mode . org-indent-mode)
   (org-mode . visual-line-mode)
   (org-mode . auto-fill-mode)
   (org-mode . (lambda () (setq-local yas-parents '(latex-mode))))
   (org-mode . ar/org-font-setup)
   (org-mode . (lambda ()
                 "Set evil-mode TAB behavior and other buffer-local settings for Org."
                 (setq-local electric-indent-local-mode nil)
                 (evil-define-key 'normal org-mode-map (kbd "TAB") 'org-cycle)))

   ;; Hooks for specialized Org buffers to provide a focused, distraction-free UI.
   (org-agenda-mode . (lambda ()
                        "Configure display for Org Agenda."
                        (visual-line-mode -1)
                        (toggle-truncate-lines 1)
                        (display-line-numbers-mode 0)
                        (setq mode-line-format nil) ; Hide modeline in agenda
                        (setq header-line-format nil)))
   (org-capture-mode . (lambda ()
                         "Hide modeline in capture buffers."
                         (setq mode-line-format nil)
                         (setq header-line-format nil))))

  :custom
  (org-directory my/org-directory)
  ;; Speed up agenda generation by specifying files.
  (org-agenda-files '("~/org/inbox.org"
                      "~/org/projects.org"
                      "~/org/habits.org"
                      "~/org/goals.org"))
  (org-default-notes-file (expand-file-name "inbox.org" my/org-directory))
  ;;(org-use-property-inheritance t) ; Allow property inheritance
  (org-log-done 'time) ; Log time when tasks are marked DONE
  (org-log-into-drawer t)
  (org-return-follows-link t) ; RET follows links
  (org-src-fontify-natively t) ; Better fontification for source blocks
  (org-pretty-entities t)  ; Display LaTeX-like entities
  ;;(org-ellipsis " ‚§µ")  ; Custom ellipsis for folded headings
  (org-cycle-separator-lines 2) ; Two blank lines between headings when cycling
  (org-startup-indented t) ; Start Org buffers indented
  (org-startup-folded 'content) ; Fold content by default
  (org-hide-leading-stars t) ; Hide leading stars for a cleaner look
  (org-confirm-babel-evaluate nil) ; Do not ask for confirmation to run code blocks
  (org-hide-emphasis-markers t) ; Hide the *, /, _, etc. emphasis markers
  (org-src-tab-acts-natively t)  ; TAB in source blocks acts like it would in that language's mode
  (org-src-preserve-indentation t) ; Preserve indentation in source blocks
  (org-startup-with-inline-images t) ; Show images inline by default
  (org-image-actual-width 600) ;  adjust them to an appropriate size
  (org-tag-alist '(("@work"      . ?w)
                   ("@home"      . ?h)
                   ("@computer"  . ?c)
                   ("@errands"   . ?e)
                   ("read"       . ?r)
                   ("meeting"    . ?m)
                   ("urgent"     . ?u)
                   ("someday"    . ?s)))
  
  (org-todo-keywords
   '((sequence "üì• TODO(t)" "‚ö° NEXT(n)" "‚öôÔ∏è PROG(p)" "‚è≥ WAIT(w@/!)" "|" "‚úÖ DONE(d!)" "‚ùå CANCEL(c@)")
     (sequence "üìù PLAN(P)" "üöÄ ACTIVE(A)" "‚è∏Ô∏è PAUSED(x)" "|" "üèÜ ACHIEVED(a)" "üóëÔ∏è DROPPED(D)")))
  (org-todo-keyword-faces
   '(("üì• TODO"      . (:foreground "#f7768e" :weight bold))
     ("‚ö° NEXT"      . (:foreground "#ff9e64" :weight bold))
     ("‚öôÔ∏è PROG"      . (:foreground "#7aa2f7" :weight bold))
     ("‚è≥ WAIT"      . (:foreground "#e0af68" :weight bold))
     ("‚úÖ DONE"      . (:foreground "#9ece6a" :weight bold))
     ("‚ùå CANCEL"    . (:foreground "#565f89" :weight bold))
     ("üìù PLAN"      . (:foreground "#73daca" :weight bold))
     ("üöÄ ACTIVE"    . (:foreground "#bb9af7" :weight bold))
     ("‚è∏Ô∏è PAUSED"    . (:foreground "#c0caf5" :weight bold))
     ("üèÜ ACHIEVED"  . (:foreground "#9ece6a" :weight bold))
     ("üóëÔ∏è DROPPED"   . (:foreground "#565f89" :weight bold))))
  
  ;; Use the element cache for a significant performance boost in Org files.
  (org-element-use-cache t)) 
#+end_src

** Babel & Structure Templates
Configure code block execution and create handy shortcuts for inserting common structures.
#+begin_src emacs-lisp
(with-eval-after-load 'org
  ;; Load common languages for Babel.
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (python . t)
     (shell . t)
     (sql . t)))

  (add-hook 'org-babel-after-execute-hook 'org-redisplay-inline-images)

  (require 'org-tempo)
  (add-to-list 'org-structure-template-alist '("sh" . "src shell"))
  (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("py" . "src python")))
#+end_src

** Visual Enhancements
This section makes Org mode beautiful and ergonomic, with modern styling and seamless Vim keybindings. The `org-modern` configuration complements the base `org-todo-keyword-faces` for a rich, thematic look.
#+begin_src emacs-lisp
(use-package org-modern
  :hook (org-mode . org-modern-mode)
  :config
  ;; This package provides a cleaner, more modern look for Org buffers.
  (setq org-modern-hide-stars "¬∑ "
        org-modern-star '("‚óâ" "‚óã" "‚óà" "‚óá" "‚óÜ" "‚ñ∑")
        org-modern-list '((43 . "‚û§") (45 . "‚Äì") (42 . "‚Ä¢"))
        org-modern-table-vertical 1
        org-modern-table-horizontal 0.1
        org-modern-block-name
        '(("src" "¬ª" "¬´")
          ("example" "¬ª" "¬´")
          ("quote" "‚ùù" "‚ùû"))

        ;; Style TODO keywords directly in the headline.
        ;; This complements the main `org-todo-keyword-faces`.
        org-modern-todo-faces
        '(("üì• TODO"      . (:foreground "#f7768e" :weight bold))
          ("‚ö° NEXT"      . (:foreground "#ff9e64" :weight bold))
          ("‚öôÔ∏è PROG"      . (:foreground "#7aa2f7" :weight bold))
          ("‚è≥ WAIT"      . (:foreground "#e0af68" :weight bold))
          ("‚úÖ DONE"      . (:background "#2f3c22" :foreground "#9ece6a" :weight bold))
          ("‚ùå CANCEL"    . (:strike-through t :foreground "#565f89"))
          ("üìù PLAN"      . (:foreground "#73daca" :weight bold))
          ("üöÄ ACTIVE"    . (:foreground "#bb9af7" :weight bold))
          ("‚è∏Ô∏è PAUSED"    . (:foreground "#c0caf5" :weight bold))
          ("üèÜ ACHIEVED"  . (:background "#364a5c" :foreground "#9ece6a" :weight bold :box t))
          ("üóëÔ∏è DROPPED"   . (:strike-through t :foreground "#565f89")))
    
        ;; Style tags with a subtle box, inspired by Doom Emacs.
        org-modern-tag-faces
        `((:foreground ,(face-attribute 'default :foreground) :weight bold :box (:line-width (1 . -1) :color "#3b4261")))
        org-modern-checkbox '((todo . "‚òê") (done . "‚òë") (cancel . "‚òí") (priority . "‚öë") (on . "‚óâ") (off . "‚óã"))))

(use-package org-appear
  :hook (org-mode . org-appear-mode)
  :config
  (setq org-appear-autoemphasis t
        org-appear-autolinks t
        org-appear-autosubmarkers t))
#+end_src

** Agenda: The Command Center
#+begin_src emacs-lisp
(use-package org-agenda
  :ensure nil
  :after org
  :custom
  (org-agenda-window-setup 'current-window)
  (org-agenda-restore-windows-after-quit t)
  (org-agenda-span 'week)
  (org-agenda-start-on-weekday nil)
  (org-agenda-start-day "today")
  (org-agenda-skip-scheduled-if-done t)
  (org-agenda-skip-deadline-if-done t)
  (org-agenda-include-deadlines t)
  (org-agenda-block-separator ?‚îÄ)
  (org-agenda-compact-blocks t)
  (org-agenda-start-with-log-mode t)
  (org-agenda-log-mode-items '(closed clock state))
  (org-agenda-clockreport-parameter-plist '(:link t :maxlevel 2))
  (org-agenda-time-grid '((daily today require-timed)
                          (800 1000 1200 1400 1600 1800 2000)
                          " ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ " "‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ"))
  (org-agenda-current-time-string "‚óÄ‚îÄ‚îÄ now ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ")

  :config
  (setq org-agenda-custom-commands
        '(("d" "üìÖ Dashboard"
           ((agenda "" ((org-deadline-warning-days 7)
                        (org-agenda-overriding-header "üìÖ Agenda")))
            (todo "‚ö° NEXT" ((org-agenda-overriding-header "‚ö° Next Tasks")))
            (tags-todo "project/üöÄ ACTIVE" ((org-agenda-overriding-header "üöÄ Active Projects")))
            (tags-todo "+PRIORITY=\"A\"" ((org-agenda-overriding-header "üî• High Priority")))
            (todo "‚è≥ WAIT" ((org-agenda-overriding-header "‚è≥ Waiting On")))
            (tags-todo "+habit" ((org-agenda-overriding-header "üîÑ Habits")))
            (stuck "" ((org-agenda-overriding-header "üö´ Stuck Projects")))))

          ("n" "‚ö° Next Tasks"
           ((todo "‚ö° NEXT" ((org-agenda-overriding-header "‚ö° Next Tasks")))))

          ("w" "üíº Work Context"
           ((tags-todo "@work/‚ö° NEXT" ((org-agenda-overriding-header "üíº Work Next")))
            (tags-todo "@work/üì• TODO" ((org-agenda-overriding-header "üíº Work Tasks")))
            (tags-todo "@work+project/üöÄ ACTIVE" ((org-agenda-overriding-header "üíº Work Projects")))))

          ("h" "üè† Home Context"
           ((tags-todo "@home/‚ö° NEXT" ((org-agenda-overriding-header "üè† Home Next")))
            (tags-todo "@home/üì• TODO" ((org-agenda-overriding-header "üè† Home Tasks")))))

          ("p" "üìã Projects Overview"
           ((tags "project" ((org-agenda-overriding-header "üìã All Projects")))))

          ("g" "üéØ Goals Review"
           ((tags-todo "goal" ((org-agenda-overriding-header "üéØ Goals")))))

          ("r" "üîç Review"
           ((agenda "" ((org-agenda-span 'day) (org-agenda-overriding-header "üìÖ Today")))
            (todo "‚úÖ DONE" ((org-agenda-overriding-header "‚úÖ Completed Today")
                             (org-agenda-skip-function '(org-agenda-skip-entry-if 'nottoday))))
            (stuck "" ((org-agenda-overriding-header "üö´ Stuck Projects"))))))))

(use-package org-super-agenda
  :after org-agenda
  ;; Use a hook to enable the mode ONLY when an Org Agenda buffer is created.
  :hook (org-agenda-mode . org-super-agenda-mode)
  ;; Use :custom to configure variables. This does not activate the mode.
  :custom
  (org-super-agenda-groups
   '((:name "üî• Overdue" :deadline past)
     (:name "üìÖ Today" :time-grid t :scheduled today)
     (:name "‚ö° Next" :todo "‚ö° NEXT")
     (:name "üî• Important" :priority "A")
     (:name "üìã Projects" :tag "project")
     (:name "üè† Home" :tag "@home")
     (:name "üíº Work" :tag "@work")
     (:name "‚è≥ Waiting" :todo "‚è≥ WAIT")
     (:name "üìö Reading" :tag "read")
     (:name "üéØ Goals" :tag "goal")
     (:name "üîÑ Habits" :tag "habit")
     (:discard (:anything t)))))
#+end_src

** Org Roam: The Knowledge Graph
Org Roam is configured for rapid, Zettelkasten-style note-taking. Templates are minimal and flexible, and the UI is integrated to feel like a natural extension of Emacs.
#+begin_src emacs-lisp
(use-package org-roam
  :defer t
  :after org
  :init
  (setq org-roam-directory my/org-roam-directory)
  (setq org-roam-db-location (expand-file-name "org-roam.db" no-littering-var-directory))
  :custom
  (org-roam-completion-everywhere t)
  (org-roam-node-display-template
   (concat "${title:*} "
           (propertize "${tags:20}" 'face 'org-tag)))
  :config
  (org-roam-db-autosync-mode)

  ;; Configure the backlinks buffer to appear in a right-hand sidebar.
  (add-to-list 'display-buffer-alist
               '("\\*org-roam\\*"
                 (display-buffer-in-direction)
                 (direction . right)
                 (window-width . 0.33)
                 (window-height . fit-window-to-buffer)))

  ;; Templates for different kinds of notes (Zettelkasten).
  (setq org-roam-capture-templates
      '(("d" "default" plain "* %?"
         :target (file+head "${slug}.org"
                            "#+title: ${title}\n#+filetags: \n\n")
         :unnarrowed t)
        ("p" "project" plain "* Goal\n\n%?\n\n* Tasks\n\n* Notes\n\n* Log\n"
         :target (file+head "projects/${slug}.org"
                            "#+title: Project: ${title}\n#+filetags: project\n")
         :unnarrowed t)
        ("l" "literature note" plain "* Source\n  - Author: \n  - Title: \n  - Year: \n\n* Summary\n\n%?\n\n* Key Takeaways\n\n* Quotes\n"
         :target (file+head "literature/${slug}.org"
                            "#+title: ${title}\n#+filetags: literature\n")
         :unnarrowed t)
        ("i" "idea" plain "* %?"
         :target (file+head "ideas/${slug}.org"
                            "#+title: ${title}\n#+filetags: idea fleeting\n")
         :unnarrowed t)
        ("z" "zettel" plain "* %?\n\n* References\n\n"
         :target (file+head "zettel/${slug}.org"
                            "#+title: ${title}\n#+filetags: zettel permanent\n")
         :unnarrowed t)
        ("j" "journal" plain "* Log\n\n%?"
         :target (file+olp+datetree (expand-file-name "journal.org" my/org-roam-directory))
         :unnarrowed t))))

(use-package org-roam-ui
  :after org-roam
  :commands (org-roam-ui-mode org-roam-ui-open)
  :custom
  (org-roam-ui-sync-theme t)
  (org-roam-ui-follow t)
  (org-roam-ui-update-on-save t)
  (org-roam-ui-open-on-start nil))

(use-package consult-org-roam
  :after (consult org-roam)
  :init (consult-org-roam-mode 1))
#+end_src

** üì• TODO Capture: The Gateway to Org
Your central inbox for capturing tasks, notes, and ideas, now featuring the
advanced dynamic project task template.
*Use dynamic directory*
#+begin_src emacs-lisp
(use-package org-capture
  :ensure nil
  :after org
  :custom
  (org-capture-templates
   '(("t" "üì• Task" entry (file+headline "~/org/inbox.org" "Tasks")
      "* üì• TODO %?\n  :PROPERTIES:\n  :CREATED: %U\n  :END:\n")

     ("n" "üìù Note" entry (file+headline "~/org/inbox.org" "Notes")
      "* %? :note:\n  :PROPERTIES:\n  :CREATED: %U\n  :SOURCE: \n  :END:\n")

     ("j" "üìî Journal" entry (file+olp+datetree "~/org/journal.org")
      "* %U %?\n")

     ("m" "ü§ù Meeting" entry (file+headline "~/org/inbox.org" "Meetings")
      "* Meeting: %? :meeting:\n  :PROPERTIES:\n  :CREATED: %U\n  :ATTENDEES: \n  :END:\n** Agenda\n** Notes\n** Action Items\n")

     ("p" "üìù Project" entry (file+headline "~/org/projects.org" "Projects")
      "* üìù PLAN %? :project:\n  :PROPERTIES:\n  :CREATED: %U\n  :GOAL: \n  :DEADLINE: \n  :END:\n** Goals\n** Tasks\n*** üì• TODO Define project scope\n** Resources\n** Notes\n")
     ;;New template to add tasks directly to existing projects.
     ("P" "üìå Project Task" entry
      (file (lambda ()
              (let* ((project-list (ar/find-org-projects))
                     (project-name (completing-read "Select Project: " project-list)))
                (cdr (assoc project-name project-list)))))
      "* üì• TODO %?\n  :PROPERTIES:\n  :CREATED: %U\n  :END:\n"
      :prepend t
      :headline "Tasks")

     ("b" "üìö Book" entry (file+headline "~/org/reading.org" "Reading List")
      "* %? :book:read:\n  :PROPERTIES:\n  :CREATED: %U\n  :AUTHOR: \n  :GENRE: \n  :PAGES: \n  :STARTED: \n  :FINISHED: \n  :RATING: \n  :END:\n** Summary\n** Key Takeaways\n** Quotes\n")

     ("h" "üîÑ Habit" entry (file+headline "~/org/habits.org" "Habits")
      "* üì• TODO %? :habit:\n  SCHEDULED: %(format-time-string \"%<<%Y-%m-%d %a .+1d>>\")\n  :PROPERTIES:\n  :CREATED: %U\n  :STYLE: habit\n  :END:\n")

     ("g" "üéØ Goal" entry (file+headline "~/org/goals.org" "Goals")
      "* üéØ GOAL %? :goal:\n  DEADLINE: %(org-read-date nil nil \"+1y\")\n  :PROPERTIES:\n  :CREATED: %U\n  :TYPE: \n  :END:\n** Why this goal?\n** Success criteria\n** Action steps\n*** üì• TODO Break down into smaller tasks\n** Resources needed\n** Potential obstacles\n** Progress tracking\n"))))
#+end_src

** Org Habit
#+begin_src emacs-lisp
(use-package org-habit
  :ensure nil
  :after org
  :custom
  (org-habit-graph-column 60)
  (org-habit-show-habits-only-for-today t)
  (org-habit-pregraph-format "  ") ;; Corrected typo
  (org-habit-graph-mature-star "‚úÖ")
  (org-habit-graph-fresh-star "üëå")
  (org-habit-graph-ready-star "üëç")
  (org-habit-graph-early-star "üå±")
  (org-habit-graph-late-star "üëé")
  (org-habit-graph-future-star "‚Ä¶"))
#+end_src

** Evil Integration
#+begin_src emacs-lisp
(use-package evil-org
  :hook (org-mode . evil-org-mode)
  :config
  (add-hook 'evil-org-mode-hook
            (lambda ()
              (evil-org-set-key-theme '(navigation insert textobjects additional calendar todo))))
  (add-to-list 'evil-emacs-state-modes 'org-agenda-mode)
  (require 'evil-org-agenda)
  (evil-org-agenda-set-keys))
#+end_src

** Keybindings
#+begin_src emacs-lisp
(ar/global-leader
 ;; Org-mode specific bindings
 "o" '(:ignore t :wk "org")
 "o a" '(org-agenda :wk "agenda")
 "o c" '(org-capture :wk "capture")
 "o s" '(org-schedule :wk "schedule")
 "o d" '(org-deadline :wk "deadline")
 "o t" '(org-set-tags-command :wk "set tags")
 
 ;; Org-roam specific bindings under "org roam"
 "o r" '(:ignore t :wk "roam")
 "o r f" '(org-roam-node-find :wk "find node")
 "o r i" '(org-roam-node-insert :wk "insert node")
 "o r c" '(org-roam-capture :wk "roam capture")
 "o r g" '(org-roam-graph :wk "show graph")
 "o r t" '(org-roam-tag-add :wk "add tag")

 "o n" '(:ignore t :which-key "org noter")
 "o n n" '(ar/org-noter-find-or-create-notes :wk "Open/Create PDF Notes")
 "o n i" '(org-noter-insert-note :wk "Insert Note"))
#+end_src

* Workflow Management
** Workspaces with *persp-mode*
*persp-mode.el* automatically creates and switches perspectives when you switch projects, a key feature for an organized workflows
#+begin_src emacs-lisp
;; (use-package persp-mode
;;   :defer t
;;   :hook (after-init . persp-mode)
;;   :init
;;   ;; Set the state file location before enabling the mode.
;;   (setq persp-state-default-file (expand-file-name "perspectives.el" no-littering-var-directory))
;;   (setq persp-mode-prefix-key (kbd "C-c p"))
;;   :custom
;;   ;; Automatically kill empty perspectives to keep the list clean.
;;   (persp-autokill-buffer-on-remove 'if-empty)
;;   (persp-sort 'create-time)
;;   (persp-kill-foreign-buffers 'if-not-redirected)
;;   ;; A smarter way to handle buffers when switching perspectives.
;;   (persp-switch-method 'vars)
;; 
;;   :config
;;   ;; Custom function to automatically create or switch to a project-specific perspective.
;;   (defun ar/projectile-switch-to-perspective ()
;;     "Switch to a perspective named after the current project, creating it if needed."
;;     (interactive)
;;     (when-let ((project-name (projectile-project-name)))
;;       (if (get-perspective project-name)
;;           (persp-switch project-name)
;;         (persp-add-new project-name)
;;         (persp-switch project-name))))
;; 
;;   ;; Hook this function into projectile to run after switching projects.
;;   (add-hook 'projectile-after-switch-project-hook #'ar/projectile-switch-to-perspective)
;; 
;;   ;; Load the saved perspectives when Emacs starts.
;;   (when (file-exists-p persp-state-default-file)
;;     (persp-load-state-from-file persp-state-default-file t)))
;; 
;; ;; Define your custom leader keybindings for workspace management.
;; (ar/global-leader
;;  ;; workspace related keybindings
;;  "w" '(:ignore t :wk "workspaces")
;;  "w n" '(persp-next :wk "next workspace")
;;  "w p" '(persp-prev :wk "previous workspace")
;;  "w s" '(persp-switch :wk "switch workspace")
;;  "w b" '(persp-switch-to-buffer :wk "switch buffer in workspace")
;;  "w c" '(persp-add-new :wk "create workspace")
;;  "w r" '(persp-rename :wk "rename workspace")
;;  "w k" '(persp-kill :wk "kill workspace"))
#+end_src

** Project Management with projectile
*proctile* is faster, more configurable, and integrates seamlessly with the rest of your ecosystem, especially `consult`.
#+begin_src emacs-lisp
;; (use-package projectile
;;   :defer t
;;   :hook (after-init . projectile-mode)
;;   :custom
;;   (setq projectile-project-search-path '("~/Projects/" "~/Code/"))
;;   (projectile-completion-system 'default) ; Use standard completing-read, which consult will enhance
;;   (projectile-enable-caching t)
;;   (projectile-switch-project-action #'projectile-dired)
;;   ;; Ignore common nuisance directories and files
;;   (projectile-globally-ignored-directories '(".git" ".idea" ".ensime_cache" ".eunit" ".svn" "node_modules" "bower_components"))
;;   (projectile-globally-ignored-files '(".#*" "*~" "*.pyc" "*.swp"))
;;   :config
;;   ;; Ensure projectile's cache is not littered in the config directory.
;;   (setq projectile-cache-file (expand-file-name "projectile.cache" no-littering-var-directory))
;; 
;;   (setq projectile-known-projects-file (expand-file-name "projectile-bookmarks.eld" no-littering-var-directory)))
;; 
;; ;; Integrates projectile with the consult completion framework.
;; (use-package consult-projectile
;;   :after (projectile consult)
;;   :config
;;   (setq consult-projectile-source
;;         (list :prompt "Project: "
;;               :action #'consult-projectile-switch-project-action)))
;; 
;; (ar/global-leader
;;  "p" '(:ignore t :wk "project (projectile)")
;;  "p p" '(projectile-switch-project :wk "switch project")
;;  "p f" '(projectile-find-file :wk "find file")
;;  "p d" '(projectile-find-dir :wk "find directory")
;;  "p b" '(consult-projectile-buffer :wk "find buffer")
;;  "p g" '(consult-ripgrep :wk "grep in project")
;;  "p s" '(:ignore t :wk "save/kill")
;;  "p s s" '(projectile-save-project-buffers :wk "save project buffers")
;;  "p s k" '(projectile-kill-buffers :wk "kill project buffers")
;;  "p c" '(projectile-compile-project :wk "compile project")
;;  "p R" '(projectile-replace :wk "replace in project"))
#+end_src

** Buffer Management: A *bufler*-style *ibuffer*
This configuration enhances the built-in `ibuffer` to group buffers by project
and special modes, mimicking the core functionality of the `bufler` package without
adding an extra dependency. The UI is modernized with custom formatting and
nerd-icons, and Evil-friendly keybindings are added for efficient management.

#+begin_src emacs-lisp
(use-package ibuffer
  :ensure nil ; Built-in package
  :commands (ibuffer)
  :hook (ibuffer-mode . ar/ibuffer-setup-hook)
  :custom
  (ibuffer-never-show-regexps
   '("\\` " ; Buffers starting with a space (e.g., *temp*)
     "\\*dashboard\\*$"
     "\\*scratch\\*$"
     "\\*Messages\\*$"
     "\\*Help\\*$"
     "\\*Backtrace\\*$"
     "\\*Compile-Log\\*$"
     "\\*Flymake diagnostics"
     "\\*eglot-events\\*$"
     "\\*Embark Collect"
     "\\*vterm\\*"))

  ;; Customize the visual format for a clean, column-based layout.
  ;; This format shows: mark, icon, buffer name, size, mode, and file path.
  (ibuffer-formats
   '((mark modified read-only " "
           (icon 4 4 :left :elide)
           (name 35 35 :left :elide)
           " "
           (size-h 9 9 :right :elide)
           " "
           (mode 16 16 :left :elide)
           " "
           filename-and-process)))

  :config
  ;; This is the main function called every time ibuffer is opened.
  (defun ar/ibuffer-setup-hook ()
    "Set up ibuffer with project grouping, icons, sorting, and evil keys."
    (nerd-icons-ibuffer-mode)
    (ar/ibuffer-set-project-groups)
    (ibuffer-do-sort-by-last-access-time)
    (ibuffer-update nil t))

  ;; This function intelligently generates the filter groups for projects.
  (defun ar/ibuffer-set-project-groups ()
    "Create and set ibuffer filter groups based on known projects."
    (let ((groups '()))
      ;; Create a group for each known project.
      (dolist (proj (project-known-projects))
        (let* ((proj-name (project-name proj))
               (proj-root (project-root proj)))
          (push `(,proj-name (:eval (and (buffer-file-name)
                                        (string-prefix-p proj-root (buffer-file-name)))))
                groups)))
      ;; Add a final catch-all group for any files not in a known project.
      (push '("Miscellaneous" (:predicate (lambda (buf)
                                            (and (buffer-file-name buf)
                                                 (not (project-buffer-p buf))))))
            groups)
      (setq ibuffer-filter-groups (nreverse groups))))

  ;; Add Evil keybindings for a more intuitive, Vim-like experience.
  (with-eval-after-load 'evil
    (evil-define-key 'normal ibuffer-mode-map
      (kbd "j") 'ibuffer-next-line
      (kbd "k") 'ibuffer-previous-line
      (kbd "d") 'ibuffer-mark-for-delete
      (kbd "x") 'ibuffer-do-delete
      (kbd "s") 'ibuffer-do-save
      (kbd "g") 'revert-buffer
      (kbd "q") 'quit-window)))

;; Ensure the `nerd-icons-ibuffer` package is loaded for the icons to work.
(use-package nerd-icons-ibuffer
  :hook (ibuffer-mode . nerd-icons-ibuffer-mode))

;; Global leader keybindings remain the same, providing clear entry points.
(ar/global-leader
  "b"   '(:ignore t :wk "buffers")
  "b b" '(consult-buffer :wk "switch buffer")
  "b i" '(ibuffer :wk "ibuffer (by project)")
  "b k" '(kill-current-buffer :wk "kill buffer")
  "b n" '(next-buffer :wk "next buffer")
  "b p" '(previous-buffer :wk "previous buffer")
  "b r" '(revert-buffer :wk "revert buffer")
  "b s" '(save-buffer :wk "save buffer"))
#+end_src

** Dired
This setup enhances the built-in Dired, turning it into a fast, modern, and feature-rich file manager that integrates perfectly with Evil mode and your other packages.
#+begin_src emacs-lisp
(use-package fd-dired
  :defer t
  :config
  (setq fd-dired-use-gnu-find-syntax t))

;; Provides commands to open files with external applications.
(use-package dired-open
  :defer t
  :config
  (setq dired-open-extensions '(("png" . "imv") ("mp4" . "mpv"))))

(use-package dired
  :ensure nil
  :commands (dired dired-jump)
  :hook (dired-mode . dired-hide-dotfiles-mode)
  :custom
  (dired-listing-switches "-agho --group-directories-first")
  (dired-auto-revert-buffer t)
  (dired-dwim-target t)
  (dired-recursive-deletes 'always)
  (dired-recursive-copies 'always)
  :config
  ;; Enable git gutter information asynchronously.
  (add-hook 'dired-mode-hook 'dired-git-info-mode)

  ;; Define evil-mode keys for a vim-like experience.
  (evil-define-key 'normal dired-mode-map
    ;; Navigation
    (kbd "h") 'dired-up-directory
    (kbd "l") 'dired-find-file-other-window ; Open in other window is often more useful
    (kbd "j") 'dired-next-line
    (kbd "k") 'dired-previous-line
    (kbd "G") 'dired-goto-file
    (kbd "gg") 'dired-first-line
    (kbd "^") 'dired-goto-root-directory
    (kbd "~") 'dired-home
    (kbd "RET") 'dired-find-file
    (kbd "i") 'dired-maybe-insert-subdir
    ;; Marking
    (kbd "m") 'dired-mark
    (kbd "u") 'dired-unmark
    (kbd "U") 'dired-unmark-all-marks
    (kbd "t") 'dired-toggle-marks
    ;; File Operations
    (kbd "C-n") 'dired-create-file
    (kbd "C-d") 'dired-create-directory
    (kbd "R") 'dired-do-rename
    (kbd "D") 'dired-do-delete
    (kbd "C") 'dired-do-copy
    (kbd "X") 'dired-open-file ; Use dired-open to open externally
    (kbd "M") 'dired-do-chmod
    (kbd "O") 'dired-do-chown))

;; dired-x for additional functionality
(use-package dired-x
  :ensure nil
  :after dired
  :custom (dired-x-hands-off-my-keys nil)
  :config
  ;; Define dired-omit-files to prevent void-variable errors
  (setq dired-omit-files "^\\.[^.]\\|^#\\|^\\.$\\|^\\.\\.$\\|\\.pyc$\\|\\.o$")
  (setq dired-omit-verbose nil))

;; Asynchronously display git status in Dired. Highly performant.
(use-package dired-git-info
  :defer t
  :commands dired-git-info-mode)

;; Adds Nerd Font icons to Dired.
(use-package nerd-icons-dired
  :hook (dired-mode . nerd-icons-dired-mode))

;; Allows editing directory listings directly (wdired) with ranger-like keys.
(use-package dired-ranger
  :after dired
  :config
  (define-key dired-mode-map (kbd "y") 'dired-ranger-copy)
  (define-key dired-mode-map (kbd "p") 'dired-ranger-paste)
  (define-key dired-mode-map (kbd "x") 'dired-ranger-move))
#+end_src

** Neotree
This setup configures *neotree*, a fast and simple file tree explorer. It is
themed with nerd-icons and integrates with evil-mode for vim-like navigation.
#+begin_src emacs-lisp
(use-package neotree
  :defer t
  :custom
  (neo-smart-open t)
  (neo-window-width 35)
  (neo-show-hidden-files t)
  (neo-autorefresh t)
  (neo-theme 'nerd-icons)
  ;; Ensure 'q' quits neotree, which is idiomatic in vim/evil.
  (evil-define-key 'normal neotree-mode-map "q" 'neotree-hide)
  (evil-define-key 'normal neotree-mode-map (kbd "TAB") 'neotree-select-window))
#+end_src

** Keybindings
#+begin_src emacs-lisp
(ar/global-leader
 "f" '(:ignore t :wk "file")
 "f f" '(find-file :wk "find file")
 "f e" '(dired (or (buffer-file-name) default-directory) :wk "explore directory")
 "f r" '(consult-recent-file :wk "find recent file")
 "f t" '(neotree-toggle :wk "toggle file tree")
 "f d" '(neotree-dir :wk "find in file tree"))
#+end_src

* Development Tools
** Envrc
#+begin_src emacs-lisp
(use-package envrc
  :hook (after-init . envrc-global-mode))
#+end_src

** Language Server Protocol: Eglot & Eglot Booster
Eglot is the built-in LSP client. It will automatically use the correct
language server from the PATH set by your direnv-managed environment. Boost
Eglot performance using eglot booster
#+begin_src emacs-lisp
(use-package lsp-mode
  :defer t
  :commands (lsp lsp-deferred)
  :hook (prog-mode . lsp-deferred)
  :init
  (setq lsp-keymap-prefix "C-c l")
  :custom
  ;; --- UI & Functionality Enhancements ---
  (lsp-semantic-tokens-enable t)
  (lsp-headerline-breadcrumb-enable t)
  (lsp-lens-enable t)
  (lsp-modeline-diagnostics-enable t)

  ;; --- Diagnostics & Completion Integration ---
  (lsp-diagnostics-provider :flycheck)
  (lsp-completion-provider :none)

  ;; --- Performance & Behavior ---
  (lsp-eldoc-render-all nil)
  (lsp-idle-delay 0.2)
  (lsp-log-io nil)
  (lsp-signature-render-documentation nil))

(use-package lsp-ui
  :defer t
  :after lsp-mode
  :commands lsp-ui-mode
  :hook (lsp-mode . lsp-ui-mode)
  :custom
  (lsp-ui-doc-position 'at-point)
  (lsp-ui-doc-show-with-mouse nil)
  (lsp-ui-sideline-show-diagnostics t)
  (lsp-ui-sideline-show-hover t)
  (lsp-ui-sideline-show-code-actions t)
  (lsp-ui-sideline-delay 0.2)
  :custom-face
  (lsp-ui-doc-background ((t (:background "#1e2030"))))
  (lsp-ui-doc-header ((t (:foreground "#7aa2f7" :weight bold))))
  (lsp-ui-sideline-background ((t (:background "#1e2030")))))

(defun lsp-booster--advice-json-parse (old-fn &rest args)
  "Try to parse bytecode instead of json."
  (or
   (when (equal (following-char) ?#)
     (let ((bytecode (read (current-buffer))))
       (when (byte-code-function-p bytecode)
         (funcall bytecode))))
   (apply old-fn args)))
(advice-add (if (progn (require 'json)
                       (fboundp 'json-parse-buffer))
                'json-parse-buffer
              'json-read)
            :around
            #'lsp-booster--advice-json-parse)

(defun lsp-booster--advice-final-command (old-fn cmd &optional test?)
  "Prepend emacs-lsp-booster command to lsp CMD."
  (let ((orig-result (funcall old-fn cmd test?)))
    (if (and (not test?)                             ;; for check lsp-server-present?
             (not (file-remote-p default-directory)) ;; see lsp-resolve-final-command, it would add extra shell wrapper
             lsp-use-plists
             (not (functionp 'json-rpc-connection))  ;; native json-rpc
             (executable-find "emacs-lsp-booster"))
        (progn
          (when-let ((command-from-exec-path (executable-find (car orig-result))))  ;; resolve command from exec-path (in case not found in $PATH)
            (setcar orig-result command-from-exec-path))
          (message "Using emacs-lsp-booster for %s!" orig-result)
          (cons "emacs-lsp-booster" orig-result))
      orig-result)))
(advice-add 'lsp-resolve-final-command :around #'lsp-booster--advice-final-command)
#+end_src

** Consult Integration
#+begin_src emacs-lisp
(with-eval-after-load 'consult
  (setq xref-show-definitions-function #'consult-xref-show-definitions)
  (setq xref-show-references-function #'consult-xref-show-references))

(use-package consult-lsp
  :after (consult lsp-mode))

(use-package consult-flycheck
  :after (consult flycheck))
#+end_src

** Robust Debugger UI
We use *dape* for debugging. The UI for debugger windows is cleanly managed by the enhanced *shackle* configuration in my *Editor Behaviour* section.
#+begin_src emacs-lisp
(use-package dap-mode
  :defer t
  :config
  ;; --- Breakpoint Persistence ---
  ;; This single line replaces the old hook-based system. It automatically
  ;; saves breakpoints on exit and reloads them on startup.
  (dap-breakpoint-persistence-mode 1)
  ;; Set the breakpoint file location to be inside the var directory.
  (setq dap-breakpoints-file (expand-file-name "dap-breakpoints.json" no-littering-var-directory))

  ;; --- Built-in UI Integration ---
  ;; Enable the automatic UI layout management.
  (dap-ui-mode 1)
  ;; Enable the floating controls for a richer debugging UI.
  (dap-ui-controls-mode 1)

  ;; Use GUD's tooltip mode for mouse-hover variable inspection in the UI buffers.
  (add-hook 'dap-ui-locals-mode-hook 'gud-tooltip-mode)
  (add-hook 'dap-ui-expressions-mode-hook 'gud-tooltip-mode))

(ar/global-leader
 ;; Debugging Keybindings (DAP)
 "d" '(:ignore t :wk "debug (dap)")
 "d d" '(dap-debug :wk "Debug new")
 "d r" '(dap-debug-recent :wk "Debug recent")
 "d c" '(dap-continue :wk "Continue")
 "d q" '(dap-disconnect :wk "Quit")
 "d b" '(dap-toggle-breakpoint :wk "Breakpoint")
 "d n" '(dap-next :wk "Next")
 "d i" '(dap-step-in :wk "Step In")
 "d o" '(dap-step-out :wk "Step Out")
 "d u" '(:ignore t :wk "UI")
 "d u o" '(dap-ui-open :wk "Open UI")
 "d u c" '(dap-ui-close :wk "Close UI")
 "d u t" '(dap-ui-toggle :wk "Toggle UI"))
#+end_src

** Syntax Checking
This setup uses the built-in *flymake* for live diagnostics, enhanced by *flymake-collection* for easy linter integration, and *apheleia* for automatic, on-save formatting.
#+begin_src emacs-lisp
(use-package flycheck
  :defer t
  :hook (prog-mode . flycheck-mode)
  :custom
  (flycheck-check-syntax-automatically '(save mode-enabled))
  (flycheck-idle-change-delay 0.2)
  :custom-face
  (flycheck-error   ((t (:underline (:style wave :color "#f7768e") :inherit nil))))
  (flycheck-warning ((t (:underline (:style wave :color "#e0af68") :inherit nil))))
  (flycheck-info    ((t (:underline (:style wave :color "#73daca") :inherit nil)))))

(use-package sideline-flycheck
  :defer t
  :hook (flycheck-mode . sideline-mode)
  :init
  (setq sideline-flycheck-display-mode 'point)
  (setq sideline-backends-right '(sideline-flycheck)))
#+end_src

** Formatting
#+begin_src emacs-lisp
(use-package apheleia
  :defer t
  :config
  (apheleia-global-mode +1))
#+end_src

** Tree-sitter for syntax highlighting
#+begin_src emacs-lisp
(with-eval-after-load 'treesit
  (add-to-list 'major-mode-remap-alist '(python-mode . python-ts-mode))
  (add-to-list 'major-mode-remap-alist '(markdown-mode . markdown-ts-mode))
  (add-to-list 'major-mode-remap-alist '(latex-mode . latex-ts-mode)))

(use-package treesit-fold
  :hook (treesit-auto-mode-hook . treesit-fold-mode))

(use-package evil-textobj-tree-sitter
  :after evil
  :config
  (define-key evil-normal-state-map (kbd "]f") (lambda () (interactive) (evil-textobj-tree-sitter-goto-textobj "function.outer")))
  (define-key evil-normal-state-map (kbd "[f") (lambda () (interactive) (evil-textobj-tree-sitter-goto-textobj "function.outer" t)))
  (define-key evil-normal-state-map (kbd "]F") (lambda () (interactive) (evil-textobj-tree-sitter-goto-textobj "function.outer" nil t)))
  (define-key evil-normal-state-map (kbd "[F") (lambda () (interactive) (evil-textobj-tree-sitter-goto-textobj "function.outer" t t))))
#+end_src

** Keybindings
#+begin_src emacs-lisp
(ar/global-leader
 "l" '(:ignore t :which-key "lsp (lsp-mode)")
 "l a" '(lsp-execute-code-action :wk "code actions")
 "l d" '(xref-find-definitions :wk "go to definition")
 "l D" '(xref-find-declarations :wk "go to declaration")
 "l i" '(xref-find-implementations :wk "go to implementation")
 "l r" '(xref-find-references :wk "find references")
 "l s" '(consult-imenu :wk "buffer symbols")
 "l S" '(consult-lsp-file-symbols :wk "project symbols")
 "l R" '(lsp-rename :wk "rename")
 "l f" '(apheleia-format-buffer :wk "format buffer")
 "l e" '(consult-flycheck :wk "buffer errors")
 "l E" '(consult-flycheck :wk "project errors")
 "l h" '(:ignore t :which-key "help")
 "l h h" '(lsp-ui-doc-show :wk "show full documentation")
 "l h d" '(lsp-ui-doc-show :wk "show doc in popup"))
#+end_src

* Python Development
** LSP: Eglot with Pyright
#+begin_src emacs-lisp
(use-package lsp-pyright
  :defer t
  :hook (python-ts-mode . (lambda () (require 'lsp-pyright) (lsp-deferred)))
  :custom
  (lsp-pyright-type-checking-mode "off"))
#+end_src

** Diagnostics: Flymake with Ruff, Mypy, and Bandit
My configuration already includes *flymake-collection*, which provides checkers for many tools. Here, we create a hook to specifically enable the checkers for Ruff, Mypy, and Bandit in any Python buffer. This gives us a powerful, multi-layered diagnostic setup without installing any extra Emacs packages.
#+begin_src emacs-lisp
(defun ar/python-diagnostics-setup ()
  "Set up a Flycheck checker chain for Python mode."
  (setq-local flycheck-checkers '(ruff mypy bandit)))
(add-hook 'python-ts-mode-hook #'ar/python-diagnostics-setup)
#+end_src

** Formatting: Apheleia with Ruff
We use *apheleia* to automatically format Python code on save. By using *ruff* as the backend, we ensure that formatting is consistent with our linter rules.
#+begin_src emacs-lisp
(with-eval-after-load 'apheleia
  (setf (alist-get 'python-ts-mode apheleia-formatters)
        '("ruff" "format" "-")))
#+end_src

** Debugging: Dape with debugpy
This integrates Python's standard debugger, *debugpy*, with the *dape* framework.
A debug template is registered, and a convenience function is created to easily
start a debug session for the current Python file.
#+begin_src emacs-lisp
(with-eval-after-load 'dap-python
  (dap-register-debug-template
   "Python (debugpy)"
   (list :type "python"
         :request "launch"
         :name "DAP: Python File"
         :program "${file}"
         :console "internalConsole"))
  (defun ar/dap-debug-python-file ()
    "Start a DAP debug session for the current Python file."
    (interactive)
    (unless (eq major-mode 'python-ts-mode)
      (error "Not in a Python buffer"))
    (dap-debug-by-template "Python (debugpy)")))
#+end_src

** Keybindings
#+begin_src emacs-lisp
(ar/global-leader
 "d" '(:ignore t :wk "debug (dap)")
 "d p" '(ar/dap-debug-python-file :wk "Debug Python File"))
#+end_src
* Markdown Environment

A production-ready setup for a modern Markdown workflow in Emacs 30. This
configuration provides live rendering, a table of contents, superior code block highlighting, powerful table editing, linting, and auto-formatting, with
intelligent conflict resolution and a robust loading order.

** Core Markdown Mode with Tree-sitter and Enhancements
This configures `markdown-mode` as the foundation. It is the core component
that all other Markdown packages will depend on.
#+begin_src emacs-lisp
(use-package markdown-mode
  :commands (markdown-mode gfm-mode)
  :mode (("\\.md\\'" . gfm-mode)
         ("\\.markdown\\'" . gfm-mode))
  :init
  :config
  ;; Fontify code blocks using their native major modes for rich highlighting.
  (setq markdown-fontify-code-blocks-natively t)

  ;; Define keybindings for both standard and Tree-sitter modes,
  ;; ensuring the keymap variables exist before trying to modify them.
  (dolist (m-map '(markdown-ts-mode-map))
    (when (boundp m-map)
      (let ((map (symbol-value m-map)))
        (define-key map (kbd "C-c C-b") #'markdown-toggle-bold)
        (define-key map (kbd "C-c C-s") #'markdown-toggle-italic)
        (define-key map (kbd "C-c C-q") #'markdown-toggle-blockquote)
        (define-key map (kbd "C-c C-l") #'markdown-insert-link)
        (define-key map (kbd "C-c C-i") #'markdown-insert-image)
        (define-key map (kbd "C-c t") #'markdown-edit-table)
        (define-key map (kbd "C-c p") #'markdown-open)
        (define-key map (kbd "C-c o") #'imenu-list-smart-toggle))))

  (add-hook 'markdown-ts-mode-hook #'treesit-fold-mode))
#+end_src

** Live In-Buffer Rendering with *md-roam*
This package provides "website-like" rendering. It depends on `markdown-mode`.
#+begin_src emacs-lisp
(use-package md-roam
  :vc (:url "https://github.com/nobiot/md-roam" :branch main)
  :after markdown-mode
  :hook (markdown-ts-mode . md-roam-mode)
  :config
  (with-eval-after-load 'markdown-mode
    (advice-add #'markdown-indent-line :before-until #'completion-at-point))
  
  (defun ar/configure-md-roam-faces ()
    "Set md-roam faces to match theme and resolve font conflicts."
    (setq-local markdown-fontify-code-blocks-natively nil)
    (set-face-attribute 'md-roam-h1-face nil :foreground "#7aa2f7" :height 1.4 :weight 'bold)
    (set-face-attribute 'md-roam-h2-face nil :foreground "#73daca" :height 1.3 :weight 'bold)
    (set-face-attribute 'md-roam-h3-face nil :foreground "#bb9af7" :height 1.2 :weight 'bold)
    (set-face-attribute 'md-roam-h4-face nil :foreground "#e0af68" :height 1.1 :weight 'bold)
    (set-face-attribute 'md-roam-h5-face nil :foreground "#ff9e64" :height 1.0 :weight 'bold)
    (set-face-attribute 'md-roam-h6-face nil :foreground "#c0caf5" :height 1.0 :weight 'bold)
    (set-face-attribute 'md-roam-code-face nil :background "#2f3c22")
    (set-face-attribute 'md-roam-blockquote-face nil :slant 'italic :foreground "#565f89"))
  (add-hook 'md-roam-mode-hook #'ar/configure-md-roam-faces))
#+end_src

** Live Linting with *flymake-markdownlint*
Integrates *markdownlint* with Flymake for on-the-fly style checking.
#+begin_src emacs-lisp
(defun ar/markdown-diagnostics-setup ()
  "Enable the markdownlint-cli checker for markdown buffers."
  (flycheck-select-checker 'markdown-markdownlint-cli))
(add-hook 'markdown-ts-mode-hook #'ar/markdown-diagnostics-setup)
#+end_src

** Auto-formatting with Apheleia
This configures *apheleia* to use *prettier* for auto-formatting.
#+begin_src emacs-lisp
(with-eval-after-load 'apheleia
  (setf (alist-get 'gfm-mode apheleia-formatters)
        '("prettier" "--prose-wrap" "always"))
  (setf (alist-get 'markdown-ts-mode apheleia-formatters)
        '("prettier" "--prose-wrap" "always")))
#+end_src

* LaTeX Writing Environment
This provides a complete scientific writing environment for both *.tex* and *.org* files. It integrates *AUCTeX* for core editing, *Tectonic* as the compiler, and a multi-layered system for completion, diagnostics, formatting, and a streamlined Zotero-based citation workflow.
** Core Backend: AUCTeX and Tectonic
This configures the foundational packages. *AUCTeX* is the primary editing environment, enhanced with *Tectonic* as the default compiler for its modern, all-in-one approach.
#+begin_src emacs-lisp
(use-package tex
  :ensure auctex
  :defer t
  :config
  ;; Set the default TeX engine to Tectonic.
  (setq TeX-engine 'tectonic)
  (add-to-list 'TeX-engine-alist
               '(tectonic "Tectonic" "tectonic -X compile %s -o %o" "tectonic -X compile %s -o %o" "tectonic -X compile %s -o %o"))

  ;; Add commands for single compilation and continuous watching.
  (setq TeX-command-list
        '(("Tectonic" "tectonic -X compile %s" TeX-run-command nil (latex-mode) :help "Compile with Tectonic")
          ("Tectonic Watch" "tectonic -X watch %s" TeX-run-command nil (latex-mode) :help "Continuously compile with Tectonic")))

  ;; Use PDF-Tools as the default viewer and enable source correlation (SyncTeX).
  (setq TeX-view-program-selection '((output-pdf "PDF Tools")))
  (setq TeX-source-correlate-mode t)
  (setq TeX-PDF-mode t)

  ;; Enable folding of macros and environments, which is built into AUCTeX.
  (add-hook 'LaTeX-mode-hook #'TeX-fold-mode))

;; Provides evil-mode integration for AUCTeX environments.
(use-package evil-tex
  :after (tex evil)
  :defer t)
#+end_src

** LSP, Completion, and Diagnostics
This section integrates modern tooling for a responsive and intelligent editing experience.
- *Eglot + Texlab:* Provides Language Server Protocol features.
- *Completion:* Merges candidates from Eglot (LSP) and AUCTeX for the most comprehensive suggestions.
- *Flymake + ChkTeX:* Offers on-the-fly syntax and style checking.
#+begin_src emacs-lisp
;; Explicitly configure lsp-latex for robust integration with texlab.
(use-package lsp-latex
  :defer t
  :after (lsp-mode tex)
  :hook (((LaTeX-mode tex-mode bibtex-mode) . lsp-deferred))
  :custom
  ;; To enable automatic building after saving, set this to t.
  (lsp-latex-build-on-save-enable nil)
  ;; Let the texlab server handle diagnostics from chktex and forward them
  ;; to lsp-mode and flycheck.
  (lsp-latex-chktex-diagnostics-on-save t))

(defun ar/latex-completion-setup ()
  "Add AUCTeX completion backend to the local completion functions."
  (add-to-list 'completion-at-point-functions #'TeX-completion-at-point-function nil t))
(add-hook 'LaTeX-mode-hook #'ar/latex-completion-setup)
#+end_src

** Auto-formatting: Apheleia and latexindent
This configures *apheleia* to use the *latexindent* tool for formatting, ensuring consistent and clean source code.
#+begin_src emacs-lisp
(with-eval-after-load 'apheleia
  ;; For standalone `.tex` files.
  (setf (alist-get 'LaTeX-mode apheleia-formatters)
        '("latexindent" "-g" "/dev/null"))

  ;; For Org mode "latex" source blocks.
  (add-to-list 'apheleia-formatters-alist
               '((latex . ("latexindent" "-g" "/dev/null")))))
#+end_src

** Citation Ecosystem: Citar and Zotero
This section configures a streamlined citation workflow centered around **Citar** and Zotero. It removes redundant packages for a simpler, more powerful setup.
#+begin_src emacs-lisp
;; RefTeX is still useful for non-citation references (labels, etc.).
(use-package reftex
  :ensure nil
  :after tex
  :config
  (add-hook 'LaTeX-mode-hook #'reftex-mode)
  (setq reftex-plug-into-AUCTeX t)
  ;; Let Citar handle the bibliography files.
  (setq reftex-default-bibliography '()))

;; Citar is the core of our citation workflow.
(use-package citar
  :hook ((latex-mode . citar-capf-setup)
         (org-mode . citar-capf-setup))
  :custom
  ;; --- CRITICAL ---
  ;; Point this to the `.bib` file that Better BibTeX for Zotero auto-exports.
  (citar-bibliography '())
  ;; Point this to your Zotero data directory to find attached PDFs.
  (citar-library-paths '("~/Zotero/storage"))
  (citar-notes-paths (list my/org-roam-directory))
  (citar-symbols
   `((file ,(nerd-icons-mdicon "nf-md-file_document") . " ")
     (note ,(nerd-icons-mdicon "nf-md-note_text") . " ")
     (link ,(nerd-icons-mdicon "nf-md-link") . " "))))

;; Integrates Citar with Org Roam to link literature notes to citations.
(use-package citar-org-roam
  :after (citar org-roam)
  :config (citar-org-roam-mode 1))

;; Provides Embark actions for Citar candidates (e.g., open PDF, open notes).
(use-package citar-embark
  :after (citar embark)
  :config (citar-embark-mode))
#+end_src

** Writing UI and Editing Enhancements
This section improves the interactive writing experience with faster math input
and aesthetic ligatures.
#+begin_src emacs-lisp
(use-package math-symbol-lists)

(use-package cdlatex
  :hook (LaTeX-mode . cdlatex-mode))

(use-package laas
  :hook (LaTeX-mode . laas-mode))

;; Use `prettify-symbols-mode` to render LaTeX macros as unicode characters.
(defun ar/latex-prettify-symbols-setup ()
  "Enable prettify-symbols-mode and add custom LaTeX ligatures."
  (prettify-symbols-mode 1)
  (mapc (lambda (rule) (push rule prettify-symbols-compose-rules))
        '(("\\sum" . ?‚àë) ("\\int" . ?‚à´) ("\\in" . ?‚àà) ("\\forall" . ?‚àÄ)
          ("\\exists" . ?‚àÉ) ("\\lambda" . ?Œª) ("\\alpha" . ?Œ±) ("\\beta" . ?Œ≤)
          ("\\gamma" . ?Œ≥) ("\\delta" . ?Œ¥) ("\\epsilon" . ?Œµ) ("\\pi" . ?œÄ)
          ("\\rightarrow" . ?‚Üí) ("\\leftarrow" . ?‚Üê) ("\\Rightarrow" . ?‚áí)
          ("\\leq" . ?‚â§) ("\\geq" . ?‚â•))))
(add-hook 'LaTeX-mode-hook #'ar/latex-prettify-symbols-setup)
#+end_src

** Org Mode Integration
#+begin_src emacs-lisp
(with-eval-after-load 'ox-latex
  ;; Configure Org's citation engine to use our Citar setup.
  (setq org-cite-global-bibliography '())
  (setq org-cite-bibliography '())
  (setq org-cite-follow-processor 'citar)
  (setq org-cite-activate-processor 'citar)

  ;; Set Tectonic as the default compiler for Org LaTeX exports.
  (setq org-latex-compiler "tectonic")
  (setq org-latex-pdf-process
        '("tectonic -X compile %f -o %o"))

  ;; Define custom LaTeX classes for flexible document creation.
  (add-to-list 'org-latex-classes
        '("article"
           "\\documentclass{article}"
           ("\\section{%s}" . "\\section*{%s}")
           ("\\subsection{%s}" . "\\subsection*{%s}")
           ("\\subsubsection{%s}" . "\\subsubsection*{%s}")) t)
  (add-to-list 'org-latex-classes
        '("beamer"
           "\\documentclass{beamer}"
           ("\\section{%s}" . "\\section*{%s}")
           ("\\subsection{%s}" . "\\subsection*{%s}")) t))
#+end_src

** Custom Snippets for Scientific Writing
#+begin_src emacs-lisp
(with-eval-after-load 'yasnippet
  ;; --- Snippet Definitions ---
  ;; We define the snippets programmatically to keep the config self-contained.
  (yas-define-snippets 'latex-mode
    '(;; -- Templates --
      ("article"
       "\\documentclass[11pt,a4paper]{article}
\\usepackage[utf8]{inputenc}
\\usepackage{amsmath}
\\usepackage{amssymb}
\\usepackage{graphicx}
\\usepackage{hyperref}
\\usepackage{siunitx}
\\usepackage{booktabs}

\\title{${1:Title}}
\\author{${2:Author}}
\\date{\\today}

\\begin{document}

\\maketitle

\\begin{abstract}
  ${3:Abstract}
\\end{abstract}

\\tableofcontents

\\section{${4:Introduction}}

$0

\\end{document}"
       "Full Scientific Article Structure"
       nil nil ("Templates"))

      ;; -- Document Structure & Environments --
      ("abs" "\\begin{abstract}\n  $0\n\\end{abstract}" "Abstract environment")
      ("fig"
       "\\begin{figure}[htbp]
  \\centering
  \\includegraphics[width=${1:0.8}\\textwidth]{${2:path/to/image}}
  \\caption{${3:Caption}}
  \\label{fig:${4:label}}
\\end{figure}
$0"
       "Figure environment")
      ("sfig"
       "\\begin{figure}[htbp]
  \\centering
  \\begin{subfigure}[b]{${1:0.45}\\textwidth}
    \\includegraphics[width=\\textwidth]{${2:img1}}
    \\caption{${3:Caption 1}}
    \\label{fig:${4:label1}}
  \\end{subfigure}
  \\hfill
  \\begin{subfigure}[b]{${1:0.45}\\textwidth}
    \\includegraphics[width=\\textwidth]{${5:img2}}
    \\caption{${6:Caption 2}}
    \\label{fig:${7:label2}}
  \\end{subfigure}
  \\caption{${8:Overall caption}}
\\end{figure}
$0"
       "Subfigure environment")
      ("table"
       "\\begin{table}[htbp]
  \\centering
  \\caption{${1:Caption}}
  \\label{tab:${2:label}}
  \\begin{tabular}{${3:l c r}}
    \\toprule
    ${4:Header 1} & ${5:Header 2} & ${6:Header 3} \\\\
    \\midrule
    ${7:data} & ${8:data} & ${9:data} \\\\
    \\bottomrule
  \\end{tabular}
\\end{table}
$0"
       "Table with booktabs")
      ("item" "\\begin{itemize}\n  \\item $0\n\\end{itemize}" "Itemize environment")
      ("enum" "\\begin{enumerate}\n  \\item $0\n\\end{enumerate}" "Enumerate environment")
      ("thm" "\\begin{theorem}\n  $0\n\\end{theorem}" "Theorem environment")
      ("lem" "\\begin{lemma}\n  $0\n\\end{lemma}" "Lemma environment")
      ("prf" "\\begin{proof}\n  $0\n\\end{proof}" "Proof environment")

      ;; -- Equations & Math --
      ("eq"
       "\\begin{equation}
  ${1:e^{i\\pi} + 1 = 0}
  \\label{eq:${2:label}}
\\end{equation}
$0"
       "Equation environment")
      ("ali"
       "\\begin{align}
  ${1:a} &= ${2:b} \\\\
  ${3:c} &= ${4:d}
  \\label{eq:${5:label}}
\\end{align}
$0"
       "Align environment for multi-line equations")
      ("mat"
       "\\begin{pmatrix}\n  ${1:a} & ${2:b} \\\\\n  ${3:c} & ${4:d}\n\\end{pmatrix}"
       "pmatrix (Matrix)")
      ("bmat"
       "\\begin{bmatrix}\n  ${1:a} & ${2:b} \\\\\n  ${3:c} & ${4:d}\n\\end{bmatrix}"
       "bmatrix (Bracketed Matrix)")
      ("lrp" "\\\\left( $1 \\\\right) $0" "Left-right parentheses")
      ("lrb" "\\\\left[ $1 \\\\right] $0" "Left-right brackets")
      ("lrc" "\\\\left\\{ $1 \\\\right\\} $0" "Left-right curly braces")
      ("sum" "\\\\sum_{${1:n=1}}^{${2:\\infty}} ${3:x_n}" "Summation")
      ("prod" "\\\\prod_{${1:n=1}}^{${2:\\infty}} ${3:x_n}" "Product")
      ("int" "\\\\int_{${1:a}}^{${2:b}} ${3:f(x)\\,dx}" "Integral")

      ;; -- Physics Specific --
      ("pd" "\\\\frac{\\\\partial ${1:y}}{\\\\partial ${2:x}} $0" "Partial derivative")
      ("dd" "\\\\frac{d ${1:y}}{d ${2:x}} $0" "Total derivative")
      ("bra" "\\\\bra{${1:\\psi}}$0" "Bra vector")
      ("ket" "\\\\ket{${1:\\psi}}$0" "Ket vector")
      ("braket" "\\\\braket{${1:\\psi}|${2:\\phi}}$0" "Braket inner product")
      ("h" "\\\\hbar" "hbar symbol")

      ;; -- Greek Letters (Prefix `g` for lowercase, `G` for uppercase) --
      ("ga" "\\\\alpha" "alpha")
      ("gb" "\\\\beta" "beta")
      ("gg" "\\\\gamma" "gamma")
      ("gd" "\\\\delta" "delta")
      ("ge" "\\\\epsilon" "epsilon")
      ("gz" "\\\\zeta" "zeta")
      ("go" "\\\\omega" "omega")
      ("GA" "\\\\Alpha" "Alpha")
      ("GB" "\\\\Beta" "Beta")
      ("GG" "\\\\Gamma" "Gamma")
      ("GD" "\\\\Delta" "Delta")
      ("GO" "\\\\Omega" "Omega")

      ;; -- Referencing & Citations --
      ("ref" "\\\\ref{${1:fig:label}}$0" "Reference")
      ("eqref" "\\\\eqref{${1:eq:label}}$0" "Equation Reference")
      ("citp" "\\\\citep{${1:key}}$0" "Parenthetical citation")
      )))
#+end_src
** Keybindings
#+begin_src emacs-lisp
(ar/global-leader
  "c" '(:ignore t :wk "compile/cite")
  "c c" '(TeX-command-master :wk "Compile Document")
  "c v" '(TeX-view :wk "View Output")
  "c e" '(TeX-clean :wk "Clean Aux Files")
  "c b" '(citar-insert-citation :wk "Insert Citation")
  "c o" '(citar-open :wk "Open Reference"))
#+end_src

* Jupyter Notebooks
This section integrates the Jupyter ecosystem into Emacs, providing a powerful,
interactive environment for Python programming directly within Org mode. It
configures Jupyter as the primary backend for Python code execution in Org,
enabling features like asynchronous evaluation, rich multimedia output, and
interactive REPLs.

** User Interface
This block configures the main *jupyter* package, which provides the user-facing
commands, REPL buffer, and kernel management UI.
#+begin_src emacs-lisp
(use-package jupyter
  :defer t
  :init
  ;; This variable must be set *before* the package loads.
  ;; It ensures that evaluating code will automatically create and associate a
  ;; REPL buffer for a seamless notebook-like experience.
  (setq jupyter-python-set-repl-for-current-buffer t)
  :custom
  ;; A list of kernelspec names that should be displayed at the top of the list.
  (jupyter-favorite-kernels '("python3"))
  ;; Do not display "Evaluating..." messages in the REPL.
  (jupyter-repl-echo-evaluating-p nil)
  :config
  ;; When this is non-nil, jupyter-org buffers will get a client for the kernel
  ;; specified by the first `python' src block upon opening the file.
  (setq jupyter-org-get-client-on-load t)

  ;; Advice to automatically enter insert state when jumping to the REPL.
  ;; This is a quality-of-life improvement for Evil users.
  (advice-add 'jupyter-org-interaction-mode :after
              (lambda () (evil-insert-state))))
#+end_src

** Execution Engine
This block is CRITICAL. It explicitly loads and configures the `ob-jupyter`
backend, which teaches Org mode how to communicate with Jupyter. All
Jupyter-related Org configurations are kept here for cohesion and to guarantee
correct load order, preventing startup errors.
#+begin_src emacs-lisp
(with-eval-after-load 'ob-jupyter
  ;; Explicitly load the jupyter language for Org Babel.
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((jupyter . t)))
  ;; Use the official jupyter function to re-route all `python` src blocks to the
  ;; jupyter babel engine. This is the cleanest and most reliable method.
  (org-babel-jupyter-override-src-block "python")

  ;; Define default header arguments for all Jupyter Python source blocks.
  ;; These ensure that results are returned to a drawer and execution is async.
  (setq org-babel-default-header-args:jupyter-python
        '((:results . "replace drawer")
          (:async . "yes")
          (:session . "python")
          (:kernel . "python3")))

  ;; Add a hook to automatically redisplay inline images (like plots) after execution.
  (add-hook 'org-babel-after-execute-hook 'org-redisplay-inline-images))
#+end_src

** Custom Functions
These helper functions streamline common notebook workflows, like clearing all
output, exporting to .ipynb, and managing the REPL.
#+begin_src emacs-lisp
(defun ar/jupyter-switch-to-repl ()
  "Switch to the Jupyter REPL buffer and go to the end."
  (interactive)
  (jupyter-org-interaction-mode)
  (with-current-buffer (jupyter-org-repl-buffer)
    (goto-char (point-max)))
  (other-window 1))

(defun ar/jupyter-insert-src-block ()
  "Insert a new python src block at point."
  (interactive)
  (org-insert-structure-template "py"))

(defun ar/jupyter-clear-all-results ()
  "Clear all Jupyter results in the current Org buffer."
  (interactive)
  (when (y-or-n-p "Clear all results in this buffer? ")
    (jupyter-org-clear-all-results)))

(defun ar/jupyter-restart-and-run-all ()
  "Restart the Jupyter kernel and evaluate all src blocks in the buffer."
  (interactive)
  (when (y-or-n-p "Restart kernel and re-evaluate all blocks? ")
    (jupyter-restart-kernel-then-execute-all)))

(defun ar/jupyter-export-to-notebook ()
  "Export the current Org buffer to a Jupyter Notebook (.ipynb) file."
  (interactive)
  (let ((filename (read-file-name "Export to notebook: " nil nil nil (format "%s.ipynb" (file-name-sans-extension buffer-file-name)))))
    (jupyter-org-export-to-notebook nil filename)))
#+end_src

** Evil Integration
This optional section provides Vim-like keybindings for navigating and
interacting with the Jupyter REPL buffer, making it consistent with the rest of
the Evil-powered environment.
#+begin_src emacs-lisp
(with-eval-after-load 'evil
  (evil-define-key 'normal jupyter-repl-interaction-mode-map
    (kbd "C-j") 'jupyter-repl-next-cell-and-execute
    (kbd "C-k") 'jupyter-repl-previous-cell)
  (evil-define-key 'insert jupyter-repl-interaction-mode-map
    (kbd "C-c C-c") 'jupyter-repl-send-buffer))
#+end_src

** Keybindings
This provides a comprehensive set of global keybindings under the "org jupyter"
prefix for managing kernels and evaluating code from anywhere.
#+begin_src emacs-lisp
(ar/global-leader
 ;; Org Jupyter Keybindings
 "o j" '(:ignore t :wk "jupyter")
 "o j e" '(jupyter-eval-src-block :wk "Eval src block")
 "o j n" '(ar/jupyter-insert-src-block :wk "New src block")
 "o j v" '(ar/jupyter-switch-to-repl :wk "View REPL")
 "o j C" '(ar/jupyter-clear-all-results :wk "Clear all results")
 "o j R" '(ar/jupyter-restart-and-run-all :wk "Restart & Run All")
 "o j X" '(ar/jupyter-export-to-notebook :wk "Export to .ipynb")
 "o j r" '(jupyter-restart-kernel :wk "Restart kernel")
 "o j i" '(jupyter-interrupt-kernel :wk "Interrupt kernel")
 "o j c" '(jupyter-connect-to-kernel :wk "Connect to kernel")
 "o j l" '(jupyter-list-kernels :wk "List kernels")
 "o j s" '(jupyter-switch-kernel :wk "Switch kernel")
 "o j k" '(jupyter-shutdown-kernel :wk "Shutdown kernel")
 "o j d" '(jupyter-doc :wk "View documentation"))
#+end_src

* Version Control
** Magit: The Core Git Client
*magit* is the central hub for all Git operations. This configuration ensures it works seamlessly with a full-frame UI and other packages.
#+begin_src emacs-lisp
(use-package magit
  :init
  (setq magit-auto-revert-mode nil)
  :commands (magit-status magit-blame)
  :custom
  ;; For a focused view, display the Magit status buffer in its own frame.
  (magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1)
  ;; Automatically save file-visiting buffers before staging changes.
  (magit-save-repository-buffers 'dont-confirmk)
  :config
  ;; When quitting Magit, this ensures the previous window configuration is restored.
  ;; The `magit-display-buffer-fullframe-status-v1` function saves the layout
  ;; to the `:magit-fullscreen` register, which we jump back to.
  (defun ar/magit-quit-and-restore-windows ()
    "Kill the Magit buffer and restore the previous window configuration."
    (interactive)
    (kill-buffer (current-buffer))
    (when (get-register :magit-fullscreen)
      (jump-to-register :magit-fullscreen)))

  ;; Bind "q" in the status buffer to our custom quitting function.
  (define-key magit-status-mode-map (kbd "q") #'ar/magit-quit-and-restore-windows))
#+end_src

** Forge: Git Forge Integration
*forge* provides integration with online Git forges (e.g., GitHub, GitLab).
#+begin_src emacs-lisp
(use-package forge
  :after magit)
#+end_src

** Magit Todos
*magit-todos* displays TODO items from your project files in the status buffer.
#+begin_src emacs-lisp
(use-package magit-todos
  :after magit
  :hook (magit-mode . magit-todos-mode))
#+end_src

** Git Timemachine
#+begin_src emacs-lisp
(use-package git-timemachine
  :after magit
  :config
  (evil-define-key 'normal git-timemachine-mode-map (kbd "C-j") 'git-timemachine-show-previous-revision)
  (evil-define-key 'normal git-timemachine-mode-map (kbd "C-k") 'git-timemachine-show-next-revision))
#+end_src

** Diff-HL: Live Diff Highlighting
#+begin_src emacs-lisp
(use-package diff-hl
  :defer t
  :hook ((after-init . global-diff-hl-mode)
         (dired-mode . diff-hl-dired-mode))
  :config
  ;; Enable flydiff mode to update diffs on the fly
  (diff-hl-flydiff-mode 1)
  ;; Integrate with magit for smooth updates
  (add-hook 'magit-post-refresh-hook #'diff-hl-magit-post-refresh))
#+end_src

** Keybindings
#+begin_src emacs-lisp
(ar/global-leader
 "g" '(:ignore t :wk "git")
 "g s" '(magit-status :wk "status")
 "g c" '(magit-commit :wk "commit")
 "g C" '(magit-commit-amend :wk "commit amend")
 "g p" '(magit-push-current-to-pushremote :wk "push")
 "g P" '(magit-pull-from-upstream :wk "pull")
 "g b" '(magit-branch :wk "branches")
 "g l" '(magit-log-buffer-file :wk "log current file")
 "g L" '(magit-log-current :wk "log current branch")
 "g d" '(magit-diff-unstaged :wk "diff")
 "g f" '(magit-fetch :wk "fetch")
 "g m" '(magit-merge :wk "merge")
 "g r" '(magit-rebase :wk "rebase")
 "g n" '(git-gutter:next-hunk :wk "next hunk")
 "g N" '(git-gutter:previous-hunk :wk "previous hunk")
 "g S" '(git-gutter:stage-hunk :wk "stage hunk"))
#+end_src

* PDF-Tools
** Core
#+begin_src emacs-lisp
(use-package pdf-tools
  :magic ("%PDF" . pdf-view-mode)
  :hook (pdf-view-mode . pdf-view-midnight-minor-mode)

  ;; Theme customization to match doom-tokyo-night.
  :custom
  ;; Use the specific Tokyonight background and foreground colors for the PDF view.
  (pdf-view-midnight-colors '("#1a1b26" . "#c0caf5"))
  ;; Enable continuous scrolling for a smoother experience.
  (pdf-view-continuous t)

  :custom-face
  ;; Customize other faces to match the Tokyonight aesthetic.
  (pdf-view-highlight-face ((t (:background "#e0af68" :foreground "#1a1b26")))) ; Yellow
  (pdf-view-link-face ((t (:foreground "#7aa2f7"))))      ; Blue
  (pdf-view-active-link-face ((t (:foreground "#bb9af7")))); Magenta

  :config
  ;; Automatically build the server executable if it's missing.
  ;; `pdf-tools-install` is idempotent and will only build if necessary.
  (pdf-tools-install :no-query)

  ;; Ensure Org mode integration is set up after Org itself is loaded.
  (with-eval-after-load 'org
    (add-to-list 'org-open-at-point-functions 'org-pdftools-open-link)
    (setq org-pdftools-link-prefix "pdf")))
#+end_src

** org-noter
#+begin_src emacs-lisp
(use-package org-noter
  :after (org pdf-view)
  :custom
  ;; Store all notes inside the dedicated `noter` directory.
  (org-noter-notes-search-path (list my/org-noter-directory))
  ;; Use a consistent naming scheme for note files.
  (org-noter-notes-file-name "%s.org")
  ;; Automatically create a new heading for each note.
  (org-noter-insert-note-no-questions t)
  ;; Keep the notes window focused after creating a note.
  (org-noter-always-focus-on-notes-buffer t)
  ;; Customize the note heading template.
  (org-noter-heading-application-function 'org-noter-insert-heading-at-point)
  (org-noter-note-heading-template "* %s\n:PROPERTIES:\n:NOTER_PAGE: %p\n:NOTER_LEFT: %l\n:NOTER_RIGHT: %r\n:END:\n\n")

  :config
  ;; Custom function to create a new notes file if one doesn't exist
  ;; or find the existing one and open it side-by-side.
  (defun ar/org-noter-find-or-create-notes ()
    "Find the notes for the current PDF or create a new notes file.
Opens the notes in a split window to the right."
    (interactive)
    (let ((pdf-path (buffer-file-name)))
      (unless pdf-path
        (error "Current buffer is not visiting a file"))
      (let* ((pdf-name (file-name-nondirectory pdf-path))
             (notes-file (expand-file-name (format "%s.org" (file-name-sans-extension pdf-name)) my/org-noter-directory)))
        (if (file-exists-p notes-file)
            (find-file notes-file)
          (progn
            (find-file notes-file)
            (insert (format "#+title: Notes on %s\n\n" pdf-name))))
        (delete-other-windows)
        (split-window-right)
        (windmove-right)
        (find-file pdf-path)))))
#+end_src

* Snippets
** Directory
#+begin_src emacs-lisp
;; This is the directory where you will store your personal snippets.
(defvar my/snippets-directory (expand-file-name "snippets" user-emacs-directory)
  "Directory for personal yasnippet snippets.")

;; Create the custom snippets directory if it doesn't exist.
(unless (file-directory-p my/snippets-directory)
  (make-directory my/snippets-directory t))
#+end_src

** Yasnippet-Snippets
*yasnippet-snippets* has to be loaded before *yasnippet* for user snippets to override the pre-built ones
#+begin_src emacs-lisp
(use-package yasnippet-snippets :demand t)
#+end_src

** Yasnippet
#+begin_src emacs-lisp
(use-package yasnippet
  :defer t
  :hook (after-init . yas-global-mode)
  :custom
  ;; Use a completing-read prompt for a better UI when multiple snippets match.
  (yas-prompt-functions '(yas-completing-prompt))
  ;; Only show important messages, hiding the "just-in-time loading" confirmation.
  :config
 
  ;; --- Add Personal Snippets Directory ---
  (add-to-list 'yas-snippet-dirs my/snippets-directory)

  ;; --- Robust, Save-Based Automatic Snippet Reloading ---
  (defun ar/yas-reload-snippets-on-save ()
    "Reload all snippets if a snippet file is being saved."
    (when (string-prefix-p my/snippets-directory (buffer-file-name))
      (yas-reload-all)
      (message "Yasnippet collection reloaded.")))

  (add-hook 'after-save-hook #'ar/yas-reload-snippets-on-save))
#+end_src

** Consult Integration
#+begin_src emacs-lisp
(use-package consult-yasnippet
  :after (consult yasnippet)
  :config
  ;; You can customize the preview behavior if desired.
  (consult-customize consult-yasnippet :preview-key 'any))
#+end_src

** Cape Integration
#+begin_src emacs-lisp
(use-package yasnippet-capf
  :after cape
  :config
  (add-to-list 'completion-at-point-functions #'yasnippet-capf))
#+end_src
** Keybindings
#+begin_src emacs-lisp
(ar/global-leader
  "s" '(:ignore t :wk "snippets")
  "s i" '(consult-yasnippet :wk "insert snippet (consult)")
  "s n" '(yas-new-snippet :wk "new snippet")
  "s v" '(yas-visit-snippet-file :wk "visit snippet file"))
#+end_src

* Markdown/Org Conversion
** md-to-org
#+begin_src emacs-lisp
;; <
(defun md-to-org (md-file &optional org-file)
  "Convert a Markdown file to Org mode format using pandoc.
MD-FILE is the input Markdown file path.
ORG-FILE is the optional output Org file path. If not provided,
it will use the same name as MD-FILE but with .org extension."
  (interactive "fMarkdown file: ")
  (let* ((input-file (expand-file-name md-file))
         (output-file (or org-file
                         (concat (file-name-sans-extension input-file) ".org")))
         (pandoc-cmd (format "pandoc -f markdown -t org %s -o %s"
                            (shell-quote-argument input-file)
                            (shell-quote-argument output-file))))
    (unless (executable-find "pandoc")
      (error "Pandoc not found. Please install pandoc to use this function"))
    (unless (file-exists-p input-file)
      (error "Input file does not exist: %s" input-file))
    (when (file-exists-p output-file)
      (unless (y-or-n-p "Output file exists. Overwrite? ")
        (error "Conversion cancelled")))
    (message "Converting %s to %s..." input-file output-file)
    (let ((result (shell-command pandoc-cmd)))
      (if (= result 0)
          (progn
            (message "Successfully converted to %s" output-file)
            (when (y-or-n-p "Open the converted file? ")
              (find-file output-file)))
        (error "Pandoc conversion failed with exit code %d" result)))))

(defun md-to-org-current-buffer ()
  "Convert the current Markdown buffer to Org mode format.
Saves the current buffer first if modified, then converts it."
  (interactive)
  (unless (buffer-file-name)
    (error "Buffer is not associated with a file"))
  (when (buffer-modified-p)
    (if (y-or-n-p "Buffer modified. Save before converting? ")
        (save-buffer)
      (error "Please save the buffer before converting")))
  (md-to-org (buffer-file-name)))

(defun md-to-org-region (start end)
  "Convert the selected region from Markdown to Org mode format using pandoc.
START and END define the region boundaries.
The converted text replaces the original region."
  (interactive "r")
  (unless (executable-find "pandoc")
    (error "Pandoc not found. Please install pandoc to use this function"))
  (unless (use-region-p)
    (error "No region selected"))
  (when (= start end)
    (error "Empty region selected"))
  
  (let* ((md-text (buffer-substring-no-properties start end))
         (temp-md-file (make-temp-file "md-to-org-" nil ".md"))
         (temp-org-file (make-temp-file "md-to-org-" nil ".org"))
         (pandoc-cmd (format "pandoc -f markdown -t org %s -o %s"
                            (shell-quote-argument temp-md-file)
                            (shell-quote-argument temp-org-file))))
    (unwind-protect
        (progn
          ;; Write markdown text to temp file with proper encoding
          (with-temp-file temp-md-file
            (insert md-text))
          ;; Convert using pandoc
          (let ((result (shell-command pandoc-cmd)))
            (if (= result 0)
                (if (file-exists-p temp-org-file)
                    (let ((org-text (with-temp-buffer
                                     (insert-file-contents temp-org-file)
                                     (buffer-string))))
                      ;; Remove trailing newline if original text didn't have one
                      (when (and (> (length org-text) 0)
                                 (not (string-suffix-p "\n" md-text))
                                 (string-suffix-p "\n" org-text))
                        (setq org-text (substring org-text 0 -1)))
                      ;; Replace the region
                      (save-excursion
                        (delete-region start end)
                        (goto-char start)
                        (insert org-text))
                      (message "Region converted from Markdown to Org mode"))
                  (error "Pandoc output file not created"))
              (error "Pandoc conversion failed with exit code %d" result))))
      ;; Clean up temp files
      (when (file-exists-p temp-md-file)
        (delete-file temp-md-file))
      (when (file-exists-p temp-org-file)
        (delete-file temp-org-file)))))

(defun md-to-org-region-to-new-buffer (start end)
  "Convert the selected region from Markdown to Org mode and show in new buffer.
START and END define the region boundaries.
Creates a new buffer with the converted content instead of replacing the region."
  (interactive "r")
  (unless (executable-find "pandoc")
    (error "Pandoc not found. Please install pandoc to use this function"))
  (unless (use-region-p)
    (error "No region selected"))
  (when (= start end)
    (error "Empty region selected"))
  
  (let* ((md-text (buffer-substring-no-properties start end))
         (temp-md-file (make-temp-file "md-to-org-" nil ".md"))
         (temp-org-file (make-temp-file "md-to-org-" nil ".org"))
         (pandoc-cmd (format "pandoc -f markdown -t org %s -o %s"
                            (shell-quote-argument temp-md-file)
                            (shell-quote-argument temp-org-file))))
    (unwind-protect
        (progn
          ;; Write markdown text to temp file
          (with-temp-file temp-md-file
            (insert md-text))
          ;; Convert using pandoc
          (let ((result (shell-command pandoc-cmd)))
            (if (= result 0)
                (if (file-exists-p temp-org-file)
                    (let ((org-text (with-temp-buffer
                                     (insert-file-contents temp-org-file)
                                     (buffer-string))))
                      ;; Create new buffer with converted content
                      (with-current-buffer (get-buffer-create "*Markdown to Org Conversion*")
                        (erase-buffer)
                        (insert org-text)
                        (org-mode)
                        (goto-char (point-min))
                        (display-buffer (current-buffer)))
                      (message "Converted text displayed in new buffer"))
                  (error "Pandoc output file not created"))
              (error "Pandoc conversion failed with exit code %d" result))))
      ;; Clean up temp files
      (when (file-exists-p temp-md-file)
        (delete-file temp-md-file))
      (when (file-exists-p temp-org-file)
        (delete-file temp-org-file)))))
#+end_src

** org-to-md
#+begin_src emacs-lisp
;; --- Org to Markdown Conversion ---
;; <
(defun org-to-md (org-file &optional md-file)
  "Convert an Org mode file to Markdown format using pandoc.
ORG-FILE is the input Org file path.
MD-FILE is the optional output Markdown file path. If not provided,
it will use the same name as ORG-FILE but with .md extension."
  (interactive "fOrg file: ")
  (let* ((input-file (expand-file-name org-file))
         (output-file (or md-file
                         (concat (file-name-sans-extension input-file) ".md")))
         (pandoc-cmd (format "pandoc -f org -t markdown %s -o %s"
                            (shell-quote-argument input-file)
                            (shell-quote-argument output-file))))
    (unless (executable-find "pandoc")
      (error "Pandoc not found. Please install pandoc to use this function"))
    (unless (file-exists-p input-file)
      (error "Input file does not exist: %s" input-file))
    (when (file-exists-p output-file)
      (unless (y-or-n-p "Output file exists. Overwrite? ")
        (error "Conversion cancelled")))
    (message "Converting %s to %s..." input-file output-file)
    (let ((result (shell-command pandoc-cmd)))
      (if (= result 0)
          (progn
            (message "Successfully converted to %s" output-file)
            (when (y-or-n-p "Open the converted file? ")
              (find-file output-file)))
        (error "Pandoc conversion failed with exit code %d" result)))))

(defun org-to-md-current-buffer ()
  "Convert the current Org buffer to Markdown format.
Saves the current buffer first if modified, then converts it."
  (interactive)
  (unless (buffer-file-name)
    (error "Buffer is not associated with a file"))
  (when (buffer-modified-p)
    (if (y-or-n-p "Buffer modified. Save before converting? ")
        (save-buffer)
      (error "Please save the buffer before converting")))
  (org-to-md (buffer-file-name)))

(defun org-to-md-region (start end)
  "Convert the selected region from Org mode to Markdown format using pandoc.
START and END define the region boundaries.
The converted text replaces the original region."
  (interactive "r")
  (unless (executable-find "pandoc")
    (error "Pandoc not found. Please install pandoc to use this function"))
  (unless (use-region-p)
    (error "No region selected"))
  (when (= start end)
    (error "Empty region selected"))
    ;; <
  (let* ((org-text (buffer-substring-no-properties start end))
         (temp-org-file (make-temp-file "org-to-md-" nil ".org"))
         (temp-md-file (make-temp-file "org-to-md-" nil ".md"))
         (pandoc-cmd (format "pandoc -f org -t markdown %s -o %s"
                            (shell-quote-argument temp-org-file)
                            (shell-quote-argument temp-md-file))))
    (unwind-protect
        (progn
          ;; Write org text to temp file with proper encoding
          (with-temp-file temp-org-file
            (insert org-text))
          ;; Convert using pandoc
          (let ((result (shell-command pandoc-cmd)))
            (if (= result 0)
                (if (file-exists-p temp-md-file)
                    (let ((md-text (with-temp-buffer
                                     (insert-file-contents temp-md-file)
                                     (buffer-string))))
                      ;; Remove trailing newline if original text didn't have one
                      (when (and (> (length md-text) 0)
                                 (not (string-suffix-p "\n" org-text))
                                 (string-suffix-p "\n" md-text))
                        (setq md-text (substring md-text 0 -1)))
                      ;; Replace the region
                      (save-excursion
                        (delete-region start end)
                        (goto-char start)
                        (insert md-text))
                      (message "Region converted from Org mode to Markdown"))
                  (error "Pandoc output file not created"))
              (error "Pandoc conversion failed with exit code %d" result))))
      ;; Clean up temp files
      (when (file-exists-p temp-org-file)
        (delete-file temp-org-file))
      (when (file-exists-p temp-md-file)
        (delete-file temp-md-file)))))

(defun org-to-md-region-to-new-buffer (start end)
  "Convert the selected region from Org to Markdown and show in new buffer.
START and END define the region boundaries.
Creates a new buffer with the converted content instead of replacing the region."
  (interactive "r")
  (unless (executable-find "pandoc")
    (error "Pandoc not found. Please install pandoc to use this function"))
  (unless (use-region-p)
    (error "No region selected"))
  (when (= start end)
    (error "Empty region selected"))

  (let* ((org-text (buffer-substring-no-properties start end))
         (temp-org-file (make-temp-file "org-to-md-" nil ".org"))
         (temp-md-file (make-temp-file "org-to-md-" nil ".md"))
         (pandoc-cmd (format "pandoc -f org -t markdown %s -o %s"
                            (shell-quote-argument temp-org-file)
                            (shell-quote-argument temp-md-file))))
    (unwind-protect
        (progn
          ;; Write org text to temp file
          (with-temp-file temp-org-file
            (insert org-text))
          ;; Convert using pandoc
          (let ((result (shell-command pandoc-cmd)))
            (if (= result 0)
                (if (file-exists-p temp-md-file)
                    (let ((md-text (with-temp-buffer
                                     (insert-file-contents temp-md-file)
                                     (buffer-string))))
                      ;; Create new buffer with converted content
                      (with-current-buffer (get-buffer-create "*Org to Markdown Conversion*")
                        (erase-buffer)
                        (insert md-text)
                        (gfm-mode) ; Use gfm-mode for Markdown
                        (goto-char (point-min))
                        (display-buffer (current-buffer)))
                      (message "Converted text displayed in new buffer"))
                  (error "Pandoc output file not created"))
              (error "Pandoc conversion failed with exit code %d" result))))
      ;; Clean up temp files
      (when (file-exists-p temp-org-file)
        (delete-file temp-org-file))
      (when (file-exists-p temp-md-file)
        (delete-file temp-md-file)))))
#+end_src
