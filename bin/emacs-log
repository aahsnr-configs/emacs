#!/usr/bin/env python3
"""
Emacs Configuration Initializer with Interactive Logging

A robust script to initialize Emacs configuration with comprehensive logging,
colored output, and Unicode support. Features interactive daemon startup
monitoring with proper error handling and resource management.

This script is designed to handle interactive prompts from Emacs, such as
package installation confirmations, by using a pseudo-terminal (pty).

Requirements: Python 3.11+, Unix-like system, Emacs
Author: Refined by Gemini based on original script
License: MIT
"""

from __future__ import annotations

import os
import pty
import select
import signal
import subprocess
import sys
import time
from contextlib import suppress
from dataclasses import dataclass, field
from datetime import datetime
from enum import StrEnum
from pathlib import Path
from typing import Final, NoReturn, TextIO


# --- Configuration and Constants ---

class LogLevel(StrEnum):
    """Log levels with semantic meaning."""
    INFO = "info"
    SUCCESS = "success"
    WARNING = "warning"
    ERROR = "error"
    DEBUG = "debug"


@dataclass(frozen=True)
class Colors:
    """ANSI color codes and Unicode symbols for enhanced terminal output."""
    RESET: Final[str] = "\033[0m"
    BOLD: Final[str] = "\033[1m"
    DIM: Final[str] = "\033[2m"
    RED: Final[str] = "\033[31m"
    GREEN: Final[str] = "\033[32m"
    YELLOW: Final[str] = "\033[33m"
    BLUE: Final[str] = "\033[34m"
    CYAN: Final[str] = "\033[36m"
    BRIGHT_GREEN: Final[str] = "\033[92m"
    BRIGHT_RED: Final[str] = "\033[91m"
    BRIGHT_CYAN: Final[str] = "\033[96m"
    CHECK_MARK: Final[str] = "âœ“"
    CROSS_MARK: Final[str] = "âœ—"
    WARNING_SIGN: Final[str] = "âš "
    INFO_SIGN: Final[str] = "â„¹"
    ARROW_RIGHT: Final[str] = "â†’"
    HOURGLASS: Final[str] = "â§—"
    SPARKLES: Final[str] = "âœ¨"
    ROCKET: Final[str] = "ðŸš€"


@dataclass(frozen=True)
class Config:
    """Immutable configuration for the Emacs setup process."""
    EMACS_DIR: Final[Path] = field(default_factory=lambda: Path.home() / ".config" / "emacs")
    LOG_DIR: Final[Path] = field(init=False)
    ORG_CONFIG_FILE: Final[str] = "Emacs.org"

    # Executable commands (can be overridden by environment variables)
    EMACS_CMD: Final[str] = os.environ.get("EMACS_CMD", "emacs")
    EMACSCLIENT_CMD: Final[str] = os.environ.get("EMACSCLIENT_CMD", "emacsclient")

    # Timeouts (in seconds)
    IO_TIMEOUT: Final[float] = 5.0
    DAEMON_CHECK_INTERVAL: Final[float] = 30.0
    SUBPROCESS_TIMEOUT: Final[float] = 60.0
    INACTIVITY_TIMEOUT: Final[float] = 300.0

    # Behavior settings
    BUFFER_SIZE: Final[int] = 4096
    MAX_OUTPUT_BUFFER: Final[int] = 1024 * 1024  # 1MB

    def __post_init__(self) -> None:
        object.__setattr__(self, "LOG_DIR", self.EMACS_DIR / "log")


# --- Custom Exceptions ---

class EmacsSetupError(Exception):
    """Base exception for Emacs setup related errors."""


class ConfigurationError(EmacsSetupError):
    """Raised when configuration-related operations fail."""


class SystemError(EmacsSetupError):
    """Raised when system requirements are not met."""


# --- Core Classes ---

class TerminalLogger:
    """Advanced terminal logger with Unicode symbols and color support."""
    def __init__(self, enable_debug: bool = False) -> None:
        self.enable_debug = enable_debug
        self.colors_enabled = self._detect_color_support()
        self.colors = Colors()
        self._symbol_cache = self._create_symbol_cache()

    def _detect_color_support(self) -> bool:
        return hasattr(sys.stdout, "isatty") and sys.stdout.isatty() and os.environ.get("TERM") != "dumb"

    def _create_symbol_cache(self) -> dict[LogLevel, str]:
        symbol_map = {
            LogLevel.INFO: (self.colors.BLUE, self.colors.INFO_SIGN),
            LogLevel.SUCCESS: (self.colors.BRIGHT_GREEN, self.colors.CHECK_MARK),
            LogLevel.WARNING: (self.colors.YELLOW, self.colors.WARNING_SIGN),
            LogLevel.ERROR: (self.colors.BRIGHT_RED, self.colors.CROSS_MARK),
            LogLevel.DEBUG: (self.colors.DIM, "â€¢"),
        }
        return {level: self._colorize(symbol, color) for level, (color, symbol) in symbol_map.items()}

    def _colorize(self, text: str, color: str) -> str:
        return f"{color}{text}{self.colors.RESET}" if self.colors_enabled else text

    def log(self, message: str, level: LogLevel = LogLevel.INFO, file: TextIO = sys.stdout) -> None:
        if level == LogLevel.DEBUG and not self.enable_debug:
            return
        symbol = self._symbol_cache.get(level, " ")
        print(f"{symbol} {message}", file=file, flush=True)

    def info(self, message: str) -> None: self.log(message, LogLevel.INFO)
    def success(self, message: str) -> None: self.log(message, LogLevel.SUCCESS)
    def warning(self, message: str) -> None: self.log(message, LogLevel.WARNING)
    def error(self, message: str) -> None: self.log(message, LogLevel.ERROR, sys.stderr)
    def debug(self, message: str) -> None: self.log(message, LogLevel.DEBUG)

    def header(self, title: str, subtitle: str = "") -> None:
        title_colored = self._colorize(title, f"{self.colors.BOLD}{self.colors.BRIGHT_CYAN}")
        print(f"\n{self.colors.SPARKLES} {title_colored}")
        if subtitle:
            print(f"  {self._colorize(subtitle, self.colors.DIM)}")
        print(self._colorize("â”€" * 60, self.colors.CYAN))

    def step(self, message: str, step_num: int) -> None:
        arrow = self._colorize(self.colors.ARROW_RIGHT, self.colors.CYAN)
        step_text = self._colorize(f"Step {step_num}", self.colors.BOLD)
        print(f"{arrow} {step_text}: {message}")


class ProcessManager:
    """Manages subprocess operations with proper cleanup and error handling."""
    def __init__(self, logger: TerminalLogger, config: Config) -> None:
        self.logger = logger
        self.config = config
        self._active_processes: list[subprocess.Popen] = []
        signal.signal(signal.SIGINT, self._signal_handler)
        signal.signal(signal.SIGTERM, self._signal_handler)

    def _signal_handler(self, signum: int, frame) -> NoReturn:
        self.logger.warning(f"\nReceived signal {signum}, cleaning up...")
        self.cleanup_all()
        sys.exit(128 + signum)

    def run_command(self, command: list[str], **kwargs) -> subprocess.CompletedProcess:
        kwargs.setdefault("timeout", self.config.SUBPROCESS_TIMEOUT)
        kwargs.setdefault("check", True)
        kwargs.setdefault("capture_output", True)
        kwargs.setdefault("text", True)
        self.logger.debug(f"Running command: {' '.join(command)}")
        try:
            return subprocess.run(command, **kwargs)
        except FileNotFoundError as e:
            raise SystemError(f"Command not found: {command[0]}") from e
        except subprocess.TimeoutExpired as e:
            raise EmacsSetupError(f"Command timed out: {' '.join(command)}") from e
        except subprocess.CalledProcessError as e:
            error_msg = f"Command failed with exit code {e.returncode}: {' '.join(command)}\n{e.stderr.strip()}"
            raise EmacsSetupError(error_msg) from e

    def start_process(self, command: list[str], **kwargs) -> subprocess.Popen:
        process = subprocess.Popen(command, **kwargs)
        self._active_processes.append(process)
        return process

    def cleanup_process(self, process: subprocess.Popen) -> None:
        if process in self._active_processes:
            self._active_processes.remove(process)
        if process.poll() is None:
            try:
                process.terminate()
                process.wait(timeout=5)
            except subprocess.TimeoutExpired:
                process.kill()
                process.wait()

    def cleanup_all(self) -> None:
        for process in self._active_processes[:]:
            self.cleanup_process(process)


class EmacsConfigurationManager:
    """Core manager for Emacs configuration and daemon setup."""
    def __init__(self, config: Config, logger: TerminalLogger) -> None:
        self.config = config
        self.logger = logger
        self.process_manager = ProcessManager(logger, config)
        self.log_file_path: Path | None = None

    def initialize(self) -> Path:
        self._validate_environment()
        self._prepare_workspace()
        return self._create_log_file()

    def _validate_environment(self) -> None:
        if sys.platform == "win32":
            raise SystemError("This script requires a Unix-like OS (Linux, macOS).")
        if not self.config.EMACS_DIR.exists():
            raise ConfigurationError(f"Emacs directory not found: {self.config.EMACS_DIR}")
        try:
            self.process_manager.run_command([self.config.EMACS_CMD, "--version"])
        except SystemError:
            raise SystemError(f"Required command '{self.config.EMACS_CMD}' not found in PATH.")

    def _prepare_workspace(self) -> None:
        try:
            os.chdir(self.config.EMACS_DIR)
            self.config.LOG_DIR.mkdir(parents=True, exist_ok=True)
        except OSError as e:
            raise ConfigurationError(f"Failed to prepare workspace: {e}") from e

    def _create_log_file(self) -> Path:
        timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
        log_file = self.config.LOG_DIR / f"emacs-daemon_{timestamp}.log"
        self.log_file_path = log_file
        try:
            log_file.touch()
            self.logger.debug(f"Log file created: {log_file}")
            return log_file
        except OSError as e:
            raise ConfigurationError(f"Cannot create log file: {e}") from e

    def cleanup_existing_instances(self) -> None:
        self.logger.step("Cleaning up existing Emacs instances", 1)
        try:
            self.process_manager.run_command([self.config.EMACSCLIENT_CMD, "-e", "(kill-emacs)"], check=False, timeout=10)
            self.logger.info("Gracefully shut down existing daemon.")
            time.sleep(2)
        except EmacsSetupError:
            self.logger.debug("No running daemon to gracefully shut down.")

    def process_configuration(self) -> None:
        self.logger.step(f"Processing configuration: {self.config.ORG_CONFIG_FILE} â†’ init.el", 2)
        org_file = self.config.EMACS_DIR / self.config.ORG_CONFIG_FILE
        if not org_file.exists():
            self.logger.warning(f"Configuration file not found, skipping tangling: {org_file}")
            return
        try:
            self.process_manager.run_command([
                self.config.EMACS_CMD, "--batch", "--eval", "(require 'org)", "--eval",
                f'(org-babel-tangle-file "{self.config.ORG_CONFIG_FILE}")'
            ])
            self.logger.success("Configuration processing complete.")
        except EmacsSetupError as e:
            raise ConfigurationError(f"Failed to process configuration: {e}") from e

    def start_daemon_interactive(self) -> bool:
        self.logger.step("Starting Emacs daemon with interactive monitoring", 3)
        self.logger.info("You can respond to any Emacs prompts that appear below.")
        self.logger.info("Package downloads/compilation may take several minutes.")
        if not self.log_file_path:
            raise EmacsSetupError("Log file path not initialized.")
        
        master_fd, slave_fd = pty.openpty()
        try:
            with open(self.log_file_path, "wb") as log_file:
                process = self.process_manager.start_process(
                    [self.config.EMACS_CMD, "--daemon"],
                    stdin=slave_fd, stdout=slave_fd, stderr=slave_fd,
                    cwd=self.config.EMACS_DIR
                )
                os.close(slave_fd)
                success = self._monitor_daemon_process(process, master_fd, log_file)
                if success:
                    self.logger.success("Emacs daemon started successfully!")
                else:
                    self.logger.error("Emacs daemon startup failed.")
                return success
        finally:
            with suppress(OSError):
                os.close(master_fd)

    def _monitor_daemon_process(self, process: subprocess.Popen, master_fd: int, log_file: TextIO) -> bool:
        start_time = time.monotonic()
        last_activity_time = start_time
        watch_fds = {master_fd, sys.stdin.fileno()}

        while True:
            if process.poll() is not None:
                return process.returncode == 0

            try:
                ready_fds, _, _ = select.select(list(watch_fds), [], [], self.config.IO_TIMEOUT)
            except (ValueError, OSError):
                break  # FDs closed

            activity_detected = False

            # Handle output from Emacs
            if master_fd in ready_fds:
                try:
                    output = os.read(master_fd, self.config.BUFFER_SIZE)
                    if output:
                        log_file.write(output)
                        log_file.flush()
                        sys.stdout.write(output.decode("utf-8", errors="replace"))
                        sys.stdout.flush()
                        activity_detected = True
                    else:  # EOF, process is likely done
                        self.logger.debug("Emacs output stream closed.")
                        watch_fds.discard(master_fd)
                except OSError:
                    watch_fds.discard(master_fd)

            # Handle user input from the terminal
            if sys.stdin.fileno() in ready_fds:
                try:
                    user_input = os.read(sys.stdin.fileno(), self.config.BUFFER_SIZE)
                    if user_input:
                        os.write(master_fd, user_input)
                        activity_detected = True
                    else:  # EOF on stdin (e.g., piped from /dev/null)
                        self.logger.debug("Stdin closed, stopping reads from it.")
                        watch_fds.discard(sys.stdin.fileno())
                except OSError:
                    watch_fds.discard(sys.stdin.fileno())

            # Update activity timer or handle inactivity
            current_time = time.monotonic()
            if activity_detected:
                last_activity_time = current_time
            else:
                time_since_activity = current_time - last_activity_time
                if time_since_activity > self.config.INACTIVITY_TIMEOUT:
                    self.logger.warning(f"No activity for {time_since_activity:.0f}s, checking daemon status...")
                    if self._test_daemon_connectivity():
                        self.logger.success("Daemon is responding despite inactivity.")
                        return True
                    else:
                        self.logger.info("Daemon not yet responding, but process is active. Continuing to wait.")
                        last_activity_time = current_time # **BUG FIX**: Reset timer and continue
                
                # Periodically check for daemon readiness during quiet periods
                elif time_since_activity > self.config.DAEMON_CHECK_INTERVAL:
                     if self._test_daemon_connectivity():
                        self.logger.success("Daemon became responsive during a quiet period.")
                        return True
        
        # Loop exited, perform final check
        return self._test_daemon_connectivity()

    def _test_daemon_connectivity(self) -> bool:
        try:
            result = self.process_manager.run_command(
                [self.config.EMACSCLIENT_CMD, "--eval", "t"], timeout=5, check=False)
            return result.returncode == 0
        except EmacsSetupError:
            return False

    def cleanup(self) -> None:
        self.process_manager.cleanup_all()


# --- Main Execution ---

def display_introduction(logger: TerminalLogger, log_file: Path) -> None:
    logger.header("Emacs Configuration Initializer", "Interactive daemon setup with comprehensive logging")
    print("This script will perform the following operations:")
    print("  1. Cleanup: Terminate any existing Emacs instances.")
    print("  2. Configuration: Tangle Org configuration to init.el.")
    print("  3. Daemon: Start Emacs daemon with interactive monitoring.")
    logger.info(f"A complete session log will be saved to: {log_file}")
    print()

def display_conclusion(logger: TerminalLogger, log_file: Path, success: bool) -> None:
    print()
    logger.header(f"{Colors.ROCKET} Setup Complete" if success else "Setup Incomplete")
    if success:
        print("You can now connect to the Emacs daemon:")
        print(f"  - GUI frame:      {Colors.BOLD}{Config.EMACSCLIENT_CMD} -c{Colors.RESET}")
        print(f"  - Terminal frame:   {Colors.BOLD}{Config.EMACSCLIENT_CMD} -t{Colors.RESET}")
        print(f"  - Stop daemon:    {Colors.BOLD}{Config.EMACSCLIENT_CMD} -e '(kill-emacs)'{Colors.RESET}")
        logger.success("Emacs daemon is ready for connections!")
    else:
        logger.error("Daemon startup failed. Please review the logs for details.")
    logger.info(f"Session log: {log_file}")

def main() -> NoReturn:
    debug_mode = os.environ.get("EMACS_SETUP_DEBUG", "").lower() in ("1", "true", "yes")
    logger = TerminalLogger(enable_debug=debug_mode)
    config = Config()
    manager = EmacsConfigurationManager(config, logger)

    try:
        log_file = manager.initialize()
        display_introduction(logger, log_file)
        manager.cleanup_existing_instances()
        manager.process_configuration()
        success = manager.start_daemon_interactive()
        display_conclusion(logger, log_file, success)
        sys.exit(0 if success else 1)
    except KeyboardInterrupt:
        logger.warning("\nSetup interrupted by user (Ctrl+C).")
        sys.exit(130)
    except (SystemError, ConfigurationError, EmacsSetupError) as e:
        logger.error(f"A critical error occurred: {e}")
        sys.exit(1)
    except Exception as e:
        logger.error(f"An unexpected error occurred: {e}")
        if debug_mode:
            import traceback
            traceback.print_exc()
        sys.exit(1)
    finally:
        manager.cleanup()

if __name__ == "__main__":
    main()
